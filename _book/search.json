[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Libro",
    "section": "",
    "text": "Programación Orientada a Objetos\nLa programación orientada a objetos (POO) es un paradigma de programación que se basa en el concepto de “objetos”, los cuales son instancias de clases. En POO, un “objeto” puede entenderse como una entidad que encapsula datos y funciones que operan sobre esos datos. Este enfoque permite modelar el mundo real de manera más efectiva, ya que se pueden representar entidades y sus interacciones de manera más natural.\nEn POO, una “clase” es un plano o plantilla para crear objetos. Define la estructura y el comportamiento de los objetos que se crearán a partir de ella. Los objetos son instancias concretas de una clase, y cada objeto puede tener sus propios datos (llamados atributos) y funciones (llamadas métodos).\nLos cuatro principios fundamentales de la POO son la encapsulación, la herencia, el polimorfismo y la abstracción. La “encapsulación” implica la ocultación de los detalles internos de un objeto y la exposición solo de lo necesario. La “herencia” permite la creación de nuevas clases basadas en clases existentes, heredando sus atributos y métodos. El “polimorfismo” permite que un objeto pueda tomar varias formas, es decir, un mismo método puede comportarse de manera diferente según el contexto. La “abstracción” consiste en simplificar la representación de un objeto centrándose en los aspectos esenciales y omitiendo los detalles innecesarios. Para el siguiente documento revisaremos las siguientes temáticas:\nPrimer Parcial\n\nControl de versionamiento\nEntorno de Desarrollo\nParadigmas de programación\nConceptos Generales de la POO\nModelamiento de clases y objetos\nCódigo limpio\nEstructura General de un Programa - ———————————————-\nLectura y escritura de datos por consola\nManejo de Excepciones\nEncapsulamiento\nConstructores\nMétodos Getter y Setters\nPersistencia de datos\nArreglos y Colecciones\n\n2 Parcial - Relaciones entre clases (Generalización/Especialización) - Revisiones de Código - Polimorfismo - Interfaces de Programación - Modelo Vista Controlador - Bases de Datos no SQL - Componentes y Objetos Gráficos\n3er Parcial - Principios SOLID - Modularidad - Introducción a Patrones de diseño - Patrones de creación - Patrones de Estructura - Patrones de Comportamiento"
  },
  {
    "objectID": "Unidades/unidad1/intro.html",
    "href": "Unidades/unidad1/intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  },
  {
    "objectID": "Unidades/unidad2/cap2.html",
    "href": "Unidades/unidad2/cap2.html",
    "title": "2  ENTORNO DE DESARROLLO.",
    "section": "",
    "text": "Un entorno de desarrollo, comúnmente conocido como IDE por sus siglas en inglés (Integrated Development Environment), es una herramienta de software integral que se utiliza para facilitar la programación y el desarrollo de software. Un IDE proporciona un conjunto de características y herramientas que ayudan a los programadores a escribir, depurar, compilar y administrar código de manera más eficiente, en otras palabras es un paquete de software que combina todas las herramientas de desarrollo en una única interfaz gráfica de usuario (GUI), Algunos ejemplos de IDE más utilizados son NetBeans, Microsoft Visual Studio, Adobe Flex Builder y Eclipse.\nAlgunos componentes comunes de un entorno de desarrollo incluyen:\nEditor de código: Ofrece funciones de edición de texto avanzadas, como resaltado de sintaxis, autoindentación y autocompletado, lo que facilita la escritura de código.\nLa Identación se refiere al formato visual utilizado para estructurar y organizar el código fuente en un lenguaje de programación.\n\n\n\n\n\nDepurador: Permite a los programadores identificar y corregir errores en su código al proporcionar herramientas para establecer puntos de interrupción, inspeccionar variables y seguir la ejecución del programa paso a paso.\nCompilador/Intérprete: Proporciona la capacidad de compilar y ejecutar el código directamente desde el IDE. Algunos IDE también son específicos para un lenguaje y pueden incluir un intérprete para ejecutar el código directamente.\nGestión de proyectos: Permite organizar y administrar proyectos de desarrollo, lo que incluye la creación, apertura y gestión de archivos y directorios.\nHerramientas de versionado: Puede integrar sistemas de control de versiones, como Git, para realizar un seguimiento de los cambios en el código y colaborar con otros desarrolladores.\nAsistencia en el desarrollo: Ofrece sugerencias y advertencias en tiempo real mientras se escribe código, lo que ayuda a detectar posibles errores y mejorar la calidad del código.\nHerramientas de construcción: Facilita la construcción y automatización de tareas, como la compilación, la generación de documentación y la ejecución de pruebas.\nHerramientas de depuración visual: Algunos IDE proporcionan una interfaz gráfica para depurar aplicaciones de manera más visual, lo que puede incluir representaciones gráficas de estructuras de datos y flujos de programa.\nIntegración con SDK y bibliotecas: Puede integrar SDK (kits de desarrollo de software) y bibliotecas relevantes para el lenguaje o plataforma de desarrollo específico.\nFinalización de código: conocida como prompt de código, esta función se utiliza para analizar todo el código y para identificar e insertar los componentes de código que faltan. Su uso permite ahorrar tiempo y minimizar los fallos o errores\nPor ejemplo, un SDK de Android proporciona las herramientas y recursos necesarios para desarrollar aplicaciones para dispositivos Android, incluyendo bibliotecas para interactuar con el hardware y el sistema operativo, herramientas de depuración, un emulador de Android para probar aplicaciones y documentación detallada.\nLos IDE varían según el lenguaje de programación y la plataforma de desarrollo. Ejemplos populares de IDE incluyen Visual Studio (para desarrollo en C# y .NET), Eclipse (para Java), IntelliJ IDEA (para Java y otros lenguajes), PyCharm (para Python) y muchos otros. La elección de un IDE suele depender de las preferencias del desarrollador y del entorno de desarrollo específico en el que trabaje.\nCARACTERISTICAS E INTSALACIÓN.\nPara este curso se utilizará los lenguajes de programación de Python y Java, por lo que instalaremos dos entornos virtuales, para sacar el mayor provecho en el caso del lenguaje de programación Java.\nEl primer entorno virtual será Visual Studio Code  y el IDE para el lenguaje de programación será Netbeans IDE 16 .\nPara la instalación del IDE Visual Studio Code hay que seguir los siguientes pasos.\nPaso 1: Descarga de VS Code\nDirígete al sitio web oficial de Visual Studio Code en https://code.visualstudio.com/ y busca un botón de descarga, generalmente ubicado en la página principal. Aquí deberías encontrar una imagen que representa el botón de descarga.\n\nPaso 2: Selecciona tu Sistema Operativo, en mi caso Windows 10.\nPaso 3: Descarga del Instalador\nDespués de seleccionar tu sistema operativo, deberías ser redirigido a una página que te permitirá descargar el instalador específico para tu plataforma. Aquí encontrarás un enlace de descarga o un botón para iniciar la descarga, donde señalarás la carpeta y realizará la descarga.\nPaso 4: Ejecuta el Instalador\nUna vez que se complete la descarga, ejecuta el instalador haciendo doble clic en él (en Windows) o siguiendo las instrucciones específicas para tu sistema operativo.\nDurante la instalación, se te pueden presentar opciones de configuración. Estas opciones pueden variar según la versión y la plataforma. Generalmente, se te preguntará si deseas crear accesos directos en el escritorio o en el menú de inicio (en el caso de Windows), así como otras preferencias.\nPaso 5: Finaliza la Instalación\nFinalmente, cuando se complete la instalación, verás una pantalla que confirma que Visual Studio Code se ha instalado correctamente.\n\nPaso 6: Configuración de los lenguajes.\nLa configuración de los lenguajes es muy importante ya que este nos permite al momento de ejecutar los archivos con sus diferentes extensiones que corran de manera correcta, para este curso instalaremos Python y luego netbeans por lo que los pasos a seguir son los siguientes:\nPaso 1: Descargar Python: Ve al sitio web oficial de Python en https://www.python.org/downloads/.\nEn la página de descargas, verás las últimas versiones de Python disponibles. Elige la versión más reciente de Python 3 (por ejemplo, Python 3.9.6).\nDesplázate hacia abajo hasta encontrar la sección de descargas de archivos ejecutables. Dependiendo de tu sistema operativo (Windows, macOS o Linux), selecciona el enlace de descarga adecuado. Para Windows, es posible que veas dos opciones: una para 32 bits y otra para 64 bits. Si tienes un sistema operativo de 64 bits, selecciona la versión de 64 bits.\nPaso 2: Ejecutar el Instalador de Python: Una vez que se complete la descarga, haz doble clic en el archivo ejecutable que descargaste para iniciar el instalador de Python.\nAsegúrate de marcar la casilla que dice “Add Python X.Y to PATH” (donde “X.Y” representa la versión de Python que estás instalando). Esto añadirá Python al PATH de tu sistema, lo que facilitará su uso desde la línea de comandos.\nHaz clic en “Install Now” para comenzar la instalación.\nPaso 3: Verificar la Instalación de Python: Abre una terminal o línea de comandos, Escribe el siguiente comando y presiona Enter:\nbash\nCopy code\npython –version\nEsto mostrará la versión de Python que has instalado, como “Python 3.9.6” o similar.\nInstalación del Netbeans."
  },
  {
    "objectID": "Unidades/unidad3/cap3.html",
    "href": "Unidades/unidad3/cap3.html",
    "title": "3  Introducción a los Paradigmas de Programación",
    "section": "",
    "text": "Los paradigmas de programación son enfoques o estilos para resolver problemas mediante código. Cada paradigma tiene sus principios, ventajas y desventajas, y está diseñado para abordar problemas de diferentes maneras. En este documento, exploraremos cuatro paradigmas principales: imperativo, declarativo, orientado a objetos y funcional.\n\n3.1 Paradigma Imperativo\n\nEl paradigma imperativo es uno de los enfoques más tradicionales. En él, el programador indica paso a paso cómo se debe realizar cada tarea.\n\nCaracterísticas:\n\nEnfoque en cambiar el estado mediante secuencias de instrucciones.\nUso intensivo de bucles y estructuras de control de flujo (if, else, for, while).\n\nEjemplo en Java\n\nEn Java, este paradigma se utiliza ampliamente debido a su sintaxis estructurada.\npublic class SumaImperativa {\n    public static void main(String[] args) {\n        int sum = 0;\n        for (int i = 1; i &lt;= 5; i++) {\n            sum += i;\n        }\n        System.out.println(\"La suma es: \" + sum);\n    }\n}\n\n3.2 Paradigma Declarativo\n\nEn el paradigma declarativo, el programador especifica qué se quiere lograr, no cómo hacerlo. Esto permite centrarse en el resultado y no en los pasos intermedios.\n\nCaracterísticas:\n\nDescribe el resultado deseado en lugar de los pasos detallados.\nMás conciso y fácil de leer para tareas específicas como consultas de bases de datos.\nEjemplo con Java y SQL\n\n\nEn Java, el uso de SQL en aplicaciones es un ejemplo de un enfoque declarativo.\nSELECT nombre, edad FROM estudiantes WHERE edad &gt; 18;\n\n3.3 Paradigma Orientado a Objetos\n\nLa programación orientada a objetos (POO) es ampliamente utilizada en Java. Este paradigma organiza el código en “objetos”, que representan entidades del mundo real.\n\nCaracterísticas:\n\nUsa conceptos de clases y objetos.\nPrincipios de abstracción, encapsulación, herencia y polimorfismo.\n\nEjemplo en Java\n\nAquí un ejemplo básico de POO en Java:\n\nclass Persona {\n    String nombre;\n    int edad;\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public void presentarse() {\n        System.out.println(\"Hola, soy \" + nombre + \" y tengo \" + edad + \" años.\");\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona(\"Ana\", 25);\n        persona.presentarse();\n    }\n}\n\n\n\n3.4 Paradigma Funcional.\n\nEl paradigma funcional trata las funciones como ciudadanos de primera clase. En este estilo, se evita el cambio de estado y las variables mutables.\n\nCaracterísticas:\n\nUso de funciones puras (sin efectos secundarios).\nUso de funciones de orden superior y técnicas como el mapeo y el filtrado.\n\nEjemplo en Java.\n\nmagina que tienes una lista de números y quieres obtener solo los números pares y calcular el doble de cada uno de ellos. En el paradigma funcional, no describimos cada paso de cómo lograr esto con bucles o variables que cambien, sino que aplicamos funciones que transforman la lista de manera declarativa. 1. Primero, aplicamos una función de filtro para seleccionar solo los números pares. 2. Luego, aplicamos una función de mapeo para multiplicar cada número par por dos. 3. Finalmente, obtenemos el resultado como una nueva lista.\nTest"
  },
  {
    "objectID": "Unidades/unidad4/cap4.html",
    "href": "Unidades/unidad4/cap4.html",
    "title": "4  Conceptos Generales de la POO",
    "section": "",
    "text": "5 Polimorfismo\nEl polimorfismo permite que objetos de diferentes clases respondan al mismo método de formas distintas, aumentando la flexibilidad del código."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#principios-fundamentales-de-la-poo",
    "href": "Unidades/unidad4/cap4.html#principios-fundamentales-de-la-poo",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.1 Principios Fundamentales de la POO",
    "text": "4.1 Principios Fundamentales de la POO\nLa POO se basa en cuatro principios clave: Clases y Objetos, Encapsulación, Herencia y Polimorfismo. A continuación, veremos cada uno en detalle."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#clases-y-objetos",
    "href": "Unidades/unidad4/cap4.html#clases-y-objetos",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.2 1 Clases y Objetos",
    "text": "4.2 1 Clases y Objetos\n\n4.2.1 Clases\nUna clase es una plantilla o modelo que define las propiedades y comportamientos de un tipo de objeto. Es como un plano que describe cómo debe ser un objeto.\n\n\n\n\n\npublic class Persona { // NOMBRE DE LA CLASE\n    String nombre;     // ATRIBUTO\n    int edad;\n\n    public void presentarse() { // METODO\n        System.out.println(\"Hola, soy \" + nombre + \" y tengo \" + edad + \" años.\");\n    }\n}\n\n\n4.2.2 Objetos\nUn objeto es una instancia concreta de una clase. Cuando se crea un objeto, se asigna un espacio en memoria y se puede interactuar con sus atributos y métodos.\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona();\n        persona.nombre = \"Ana\";\n        persona.edad = 25;\n        persona.presentarse();\n    }\n}\nEn este ejemplo, persona es un objeto de la clase Persona con atributos nombre y edad."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#encapsulación",
    "href": "Unidades/unidad4/cap4.html#encapsulación",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.3 2. Encapsulación",
    "text": "4.3 2. Encapsulación\nLa encapsulación consiste en restringir el acceso directo a ciertos datos de un objeto, protegiendo sus atributos para que solo se modifiquen a través de métodos específicos.\n\n\n\n\n\n\n4.3.1 Ejemplo de Encapsulación\nclass Persona {\n    public String nombre;\n    private int edad;\n\n    public Persona(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String getEdad() {\n        return edad;\n    }\n\n    public void setEdad(int edad) {\n        this.edad = edad;\n    }\n}\nEn este caso, el atributos nombre es público y edad es privados, y solo se pueden acceder mediante los métodos getEdad() y setEdad()."
  },
  {
    "objectID": "Unidades/unidad4/cap4.html#herencia",
    "href": "Unidades/unidad4/cap4.html#herencia",
    "title": "4  Conceptos Generales de la POO",
    "section": "4.4 3 Herencia",
    "text": "4.4 3 Herencia\nLa herencia permite que una clase (subclase) herede atributos y métodos de otra clase (superclase), permitiendo reutilizar código y extender funcionalidades.\n\n\n\n\n\nEjemplo de Herencia\nclass Animal {\n  public String nombre;\n  public Animal (String nombre){\n    this.nombre = nombre;\n  } \n  public void sonido() {\n        System.out.println(\"El animal hace un sonido\");\n  }\n}\n\nclass Perro extends Animal {\n  @Override\n  public void sonido() {\n      System.out.println(\"El perro ladra\");\n  }\n}\nAquí, Perro es una subclase de Animal y hereda el atributo nombre y su método sonido(), que luego sobrescribimos (@verride) para proporcionar un comportamiento específico."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#tipos-de-relaciones-diagramas-de-casos-de-usos.",
    "href": "Unidades/unidad5/cap5.html#tipos-de-relaciones-diagramas-de-casos-de-usos.",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.1 TIPOS DE RELACIONES | DIAGRAMAS DE CASOS DE USOS.",
    "text": "5.1 TIPOS DE RELACIONES | DIAGRAMAS DE CASOS DE USOS.\nLos diagramas de casos de uso muestran los casos de uso, los actores y las relaciones entre ellos. \nEs, con total seguridad, el diagrama más conocido y es utilizado para representar los actores externos que interactúan con el sistema de información y a través de que funcionalidades (casos de uso o requisitos funcionales) se relacionan. Dicho de otra manera, muestra de manera visual las distintas funciones que puede realizar un usuario (más bien un tipo de usuario) de un Sistema de Información.\nLo primero es saber cual es su finalidad. El diagrama de casos de uso, dependiendo de la profundidad que le demos, puede ser utilizado para muchos fines, entre ellos podemos encontrar los siguientes:\n\nRepresentar los requisitos funcionales.\nRepresentar los actores que se comunican con el sistema. Normalmente los actores del sistema son los usuarios y otros sistemas externos que se relacionan con el sistema. En el caso de los usuarios hay que entender el actor como un “perfil”, pudiendo existir varios usuarios que actúan como el mismo actor.\nRepresentar las relaciones entre requisitos funcionales y actores.\nGuiar el desarrollo del sistema. Crear un punto de partida sobre el que empezar a desarrollar el sistema.\nComunicarse de forma precisa entre cliente y desarrollador. Simplifica la forma en que todos los participes del desarrollo, incluyendo el cliente, perciben como el sistema funcionará y ofrecerá una visión general común del mismo."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#elementos-de-un-diagrama-de-casos-de-uso",
    "href": "Unidades/unidad5/cap5.html#elementos-de-un-diagrama-de-casos-de-uso",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.2 Elementos de un diagrama de casos de uso",
    "text": "5.2 Elementos de un diagrama de casos de uso\nUn diagrama de casos de uso está compuesto, principalmente, de 3 elementos: Actores, Casos de uso y Relaciones.\nLa interacción entre actores no se ve en el diagrama de casos de uso. Si esta interacción es esencial para una descripción coherente del comportamiento deseado, quizás los límites del sistema o del caso de uso deban de ser re-examinados. Alternativamente, la interacción entre actores puede ser parte de suposiciones usadas en el caso de uso. Sin embargo, los actores son una especie de rol, un usuario humano u otra entidad externa puede jugar varios papeles o roles. Así el Chef y el Cajero podrían ser realmente la misma persona.\n\n\n5.2.1 Actores\nComo ya hemos comentado en la presentación, un actor es algo o alguien externo al sistema que interactúa de forma directa con el sistema. Cuando decimos que interactúa nos referimos a que aporta información, recibe información, inicia una acción…\nSe representan con una imagen de un “muñeco de palo” con el nombre del actor debajo\n\nExisten dos tipos de actores: Los usuarios y los sistemas.\nNo hay que entender los usuarios como personas singulares, sino como “perfiles o roles” que identifican a un tipo de usuario, pero no al usuario en sí. Por ejemplo, en una aplicación de gestión de nóminas, un actor de este tipo podría ser “gestor de nóminas” que se encarga de emitir y firmar nóminas. Este rol podría ser tomado, por ejemplo, por cualquier individuo del personal de recursos humanos y, además, por el jefe de la empresa. Es un ejemplo muy sencillo, pero como puedes ver, un actor no representa a una única persona o a un único usuario.\n\nPor otro lado, los actores pueden ser otros sistemas que también interactúan con nuestro propio sistema. Un ejemplo podría ser, en nuestra aplicación de nóminas, un sistema que almacene las nóminas firmadas a modo de archivo. En este caso cuando se firma la nómina se recibe la misma por el sistema de archivo, por tanto el caso de uso se relaciona con el actor.\n\nEn ocasiones este tipo de actores no se representa con un “hombre de palo” porque puede dar la sensación de que es un usuario y queda poco intuitivo."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#relaciones",
    "href": "Unidades/unidad5/cap5.html#relaciones",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.3 Relaciones",
    "text": "5.3 Relaciones\nLas relaciones conectan los casos de uso con los actores o los casos de uso entre sí.\nCuando conectan un actor con un caso de uso representa que ese actor interactúa de alguna manera con ese caso de uso y se representa con una linea continua con la identificación &lt;&lt;communicates&gt;&gt;.\n\nCuando conectan casos de uso entre sí se pueden diferenciar dos tipos de relaciones: &lt;&lt;include&gt;&gt; y &lt;&lt;extends&gt;&gt;. En español a veces se usa la nomenclatura &lt;&lt;usa&gt;&gt; y &lt;&lt;extiende&gt;&gt;:\n\n&lt;&lt;include&gt;&gt;: Se utiliza para representar que un caso de uso utiliza siempre a otro caso de uso. Es decir, un caso de uso se ejecutará obligatoriamente (lo incluye, lo usa). Se representa con una flecha discontinua que va desde el caso de uso de origen al caso de uso que se incluye.\n\n\nUn uso típico de este tipo de relaciones se produce cuando dos casos de uso comparten una funcionalidad. Esa funcionalidad es extraida de los dos y se crea un caso de uso nuevo que se relaciona con los anteriores con un include.\n\nEn este ejemplo, los casos de uso emitir factura y enviar producto ejecutarán ambos el caso de uso autenticación.\n\n&lt;&lt;extend&gt;&gt;: Este tipo de relaciones se utilizan cuando un caso de uso tiene un comportamiento opcional, reflejado en otro caso de uso. Es decir, un caso de uso puede ejecutar, normalmente dependiendo de alguna condición o flujo del programa, otro caso de uso. Se representa con una flecha discontinua que va desde el caso de uso opcional al original.\n\n\nUn ejemplo de esta relación podría ser la siguiente:\n\nEn este supuesto el caso de uso Hacer pedido puede dar lugar (o no) a otros dos casos de uso: Enviar notificación SMS y Enviar notificación email. Se supone que, cuando un usuario hace un pedido, el sistema le permite elegir si quiere que se envíe una notificación de ese pedido por SMS o por email"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#tipos-de-relaciones.",
    "href": "Unidades/unidad5/cap5.html#tipos-de-relaciones.",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.4 Tipos de relaciones.",
    "text": "5.4 Tipos de relaciones.\nPara una mejor explicación del tipo de relaciones hagamos un ejemplo teniendo presente el siguiente diagrama.\n\nEn el grafico anterior podemos observar que consta de lo siguiente: nombre | atributos | métodos.\nCon esta información realicemos ejemplos para un mejor entendimiento.\nSi tenemos una clase denominada Animales, cuyos atributos son nombre, ID, edad y sus métodos son definirNombre y comer.\nPara esto tener presente la información de la imagen siguiente.\n\nEs decir para representar atributos privados sería de la siguiente manera:\n-nombre | Atributo privado\n+ID | Atributo público\n#edad | Atributo protegido.\nTeniendo la representación de la clase como se observa en la siguiente imagen.\n\nQue sucedería si se quisiera crear 2 animales diferentes un perro y un gato.\n\nTendríamos el siguiente diagrama, sin embargo, aplicando el principio de herencia, podemos re utilizar el código, como se observa en la imagen siguiente.\n\nLa clase animales en la imagen anterior toma el nombre de clase padre o superclase y las clases de perro y gato toman el nombre de subclase o clase hija."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#tipos-de-relaciones-en-diagramas-de-clases-uml",
    "href": "Unidades/unidad5/cap5.html#tipos-de-relaciones-en-diagramas-de-clases-uml",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.5 Tipos de relaciones en diagramas de clases UML:",
    "text": "5.5 Tipos de relaciones en diagramas de clases UML:\n\n\n\n\n\n\n5.5.1 Relación (Línea continua con flecha)\n\nEjemplo: Persona tiene una relación con Empleo.\nDescripción: Esta relación indica que una clase (Persona) está asociada a otra clase (Empleo). En este caso, una persona puede tener un empleo, lo que representa una asociación básica entre estas dos entidades.\nSímbolo: Línea continua con flecha.\n\n\n\n5.5.2 Implementación (Línea continua con triángulo)\n\nEjemplo: PagoConTarjeta implementa la InterfazPago.\nDescripción: En este caso, PagoConTarjeta debe proporcionar una implementación del método procesarPago() definido en la interfaz InterfazPago. Esto significa que PagoConTarjeta se compromete a cumplir con el contrato especificado por la interfaz.\nSímbolo: Línea continua con triángulo en la dirección de la interfaz.\n\n\n\n5.5.3 Composición (Línea continua con diamante lleno)\n\nEjemplo: Edificio contiene Aulas.\nDescripción: La composición representa una relación fuerte de “parte de”. En este caso, las aulas forman parte del edificio, y si el edificio se destruye, las aulas también desaparecen. Aula no puede existir sin Edificio.\nSímbolo: Línea continua con diamante lleno en el lado del todo (Edificio).\n\n\n\n5.5.4 Asociación (Línea continua)\n\nEjemplo: Profesor y Estudiante están asociados.\nDescripción: Indica una relación entre dos clases en la que ambas pueden interactuar entre sí. En este caso, un Profesor enseña a un Estudiante. Es una relación básica, sin dependencia fuerte ni implicaciones de pertenencia.\nSímbolo: Línea continua sin ningún otro símbolo.\n\n\n\n5.5.5 Herencia (Línea discontinua con triángulo)\n\nEjemplo: Carro hereda de Vehiculo.\nDescripción: La herencia indica una relación “es un tipo de”. Carro hereda de Vehiculo, lo que significa que Carro es una especialización de Vehiculo y hereda sus atributos y métodos. Este es un caso de polimorfismo donde Carro puede ser tratado como Vehiculo.\nSímbolo: Línea discontinua con triángulo apuntando hacia la superclase (Vehiculo).\n\n\n\n5.5.6 Dependencia (Línea discontinua con flecha)\n\nEjemplo: Usuario depende de AutenticacionService.\nDescripción: La dependencia indica que una clase (Usuario) utiliza otra clase (AutenticacionService) temporalmente para realizar una acción. En este ejemplo, Usuario depende de AutenticacionService para iniciar sesión. La relación es débil, lo que significa que Usuario solo necesita AutenticacionService temporalmente.\nSímbolo: Línea discontinua con flecha apuntando hacia la clase de la que depende (AutenticacionService).\n\n\n\n5.5.7 Agregación (Línea continua con diamante vacío)\n\nEjemplo: Perrera agrega Perro.\nDescripción: La agregación representa una relación de “parte de” débil. Perro es una parte de Perrera, pero puede existir independientemente de ella. Es decir, si la Perrera deja de existir, los Perros pueden seguir existiendo.\nSímbolo: Línea continua con un diamante vacío en el lado del todo (Perrera)."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#asociación",
    "href": "Unidades/unidad5/cap5.html#asociación",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.6 Asociación:",
    "text": "5.6 Asociación:\nUtilizando una linea simple la asociación indica una relación entre dos clases sin dependencia.\nEjemplo si ahora creamos un animal (PEZ), podemos decir que los gatos pueden comer peces utilizando el diagrama que se observa en la siguiente imagen."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#agregación",
    "href": "Unidades/unidad5/cap5.html#agregación",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.7 Agregación:",
    "text": "5.7 Agregación:\nEs un tipo especial de asociación que especifíca un todo y sus partes, esta relación indica que los elementos pueden existir fuera del todo. Ejemplo:\nSi creamos una clase Perro, y una clase Perrera, el perro podría pertenecer a la clase Perrera, pero no depende necesariamente la clase perro de la perrera y se representa como se observa en la siguiente imagen."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#composición",
    "href": "Unidades/unidad5/cap5.html#composición",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.8 Composición:",
    "text": "5.8 Composición:\nEs la relación en la que la parte no puede existir fuera del todo sin la otra clase. Ejemplo, si tenemos un centro de visitantes en la cual tenga varios espacios físicos como recepción y baños, Si el centro de visitantes se derrumbara sus espacios físicos como recepción y baño no podrían exisitir separados."
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#multiplicidad.",
    "href": "Unidades/unidad5/cap5.html#multiplicidad.",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.9 Multiplicidad.",
    "text": "5.9 Multiplicidad.\nPermite restringir las restricciones numéricas de dependencia.\nEjemplo si queremos especificar que el centro de visitantes tiene un solo centro de recepción, y que puede tener uno o varios baños, se puede realizar la siguiente manera.\n\nSi tienes más dudas, te sugiero revisar el siguiente video:"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#plantiumuml-herramienta",
    "href": "Unidades/unidad5/cap5.html#plantiumuml-herramienta",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.10 PlantiumUML herramienta",
    "text": "5.10 PlantiumUML herramienta\n@startuml\nclass Persona {\n    + nombre : String\n    + correr() : void\n}\n@enduml\n@startuml\nclass Persona {\n    + nombre : String\n    + correr() : void\n}\n\nclass Estudiante extends Persona {\n    + matricula : String\n    + estudiar() : void\n}\n@enduml"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#plantiumuml-video",
    "href": "Unidades/unidad5/cap5.html#plantiumuml-video",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.11 PlantiumUML Video",
    "text": "5.11 PlantiumUML Video"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#video",
    "href": "Unidades/unidad5/cap5.html#video",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.12 Video",
    "text": "5.12 Video"
  },
  {
    "objectID": "Unidades/unidad5/cap5.html#test",
    "href": "Unidades/unidad5/cap5.html#test",
    "title": "5  Modelamiento de clases y objetos.",
    "section": "5.13 TEST",
    "text": "5.13 TEST"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#funciones-y-métodos-los-nombres-de-funciones-y-métodos-deben-describir-lo-que-hacen.-es-una-buena-práctica-que-los-nombres-sean-verbos-o-frases-verbales.",
    "href": "Unidades/unidad6/cap6.html#funciones-y-métodos-los-nombres-de-funciones-y-métodos-deben-describir-lo-que-hacen.-es-una-buena-práctica-que-los-nombres-sean-verbos-o-frases-verbales.",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.1 Funciones y Métodos Los nombres de funciones y métodos deben describir lo que hacen. Es una buena práctica que los nombres sean verbos o frases verbales.",
    "text": "6.1 Funciones y Métodos Los nombres de funciones y métodos deben describir lo que hacen. Es una buena práctica que los nombres sean verbos o frases verbales.\n\nEjemplo de un mal nombre:\n\n void d();  // ¿Qué significa \"d\"?\n\nEjemplo de un buen nombre:\n\n void dibujarRectangulo();"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#funciones-simples-y-de-responsabilidad-única",
    "href": "Unidades/unidad6/cap6.html#funciones-simples-y-de-responsabilidad-única",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.2 Funciones Simples y de Responsabilidad Única",
    "text": "6.2 Funciones Simples y de Responsabilidad Única\nLas funciones deben ser cortas y realizar solo una tarea específica. Una función que intenta hacer muchas cosas es difícil de entender y mantener.\n\nEjemplo En lugar de hacer todo en una sola función, divide las tareas en funciones separadas.\nEjemplo de función compleja:\n\nvoid procesarDatosYGuardarEnBD() { // Procesa datos // Guarda en la base de datos \n}\nEjemplo de funciones separadas:\nvoid procesarDatos() {     // Procesa datos \n     }\nvoid guardarEnBD() {     // Guarda en la base de datos \n     }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#evitar-comentarios-innecesarios",
    "href": "Unidades/unidad6/cap6.html#evitar-comentarios-innecesarios",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.3 Evitar Comentarios Innecesarios",
    "text": "6.3 Evitar Comentarios Innecesarios\nUn código limpio debería ser lo suficientemente claro para no necesitar comentarios. Si sientes que necesitas comentar para explicar el código, es probable que el código en sí necesite ser refactorizado.\n\nEjemplo\n\nCódigo con comentarios innecesarios:\nint edad = 25; // Declara la edad del usuario \nCódigo claro sin comentarios:\nint edadUsuario = 25;"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#evitar-código-duplicado",
    "href": "Unidades/unidad6/cap6.html#evitar-código-duplicado",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.4 Evitar Código Duplicado",
    "text": "6.4 Evitar Código Duplicado\nEl código duplicado genera inconsistencias y es difícil de mantener. Si necesitas hacer algo similar en múltiples lugares, utiliza funciones o métodos para reducir la duplicación.\nEjemplo de código duplicado:\n\nint calcularAreaRectangulo (int ancho, int alto) {\n          return ancho * alto; \n          }  \n\nint calcularAreaCuadrado(int lado) {\n          return lado * lado; \n          } \n          \nEjemplo de código refactorizado:\n\nint calcularArea(int ancho, int alto) {\n      return ancho * alto; \n      }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#control-de-excepciones-y-errores",
    "href": "Unidades/unidad6/cap6.html#control-de-excepciones-y-errores",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.5 Control de Excepciones y Errores",
    "text": "6.5 Control de Excepciones y Errores\nEl manejo de excepciones debe ser claro y específico. No uses excepciones generales como catch (Exception e) y evita el abuso de excepciones para el control de flujo.\n\nEjemplo\n\nMal manejo de excepciones:\n\ntry {\n// Código \n    } catch (Exception e) {\n        System.out.println(\"Ocurrió un error\"); \n    }\n    \nBuen manejo de excepciones:\n\ntry {     \n    \n      // Código \n    \n    } catch (IOException e) {  \n      \n      System.out.println(\"Error de entrada/salida\"); \n      \n      } catch (NullPointerException e) {\n      \n      System.out.println(\"Error: valor nulo encontrado\");\n      \n      }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#uso-de-formato-consistente",
    "href": "Unidades/unidad6/cap6.html#uso-de-formato-consistente",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.6 Uso de Formato Consistente",
    "text": "6.6 Uso de Formato Consistente\nEl código debe tener un formato consistente para mejorar su legibilidad. Esto incluye el uso adecuado de sangría, espacios y estilo de llaves. Además, el equipo de desarrollo debe seguir una convención de formato común.\n\n6.6.1 Ejemplo\nMal formato:\n\nif(condicion){ \n    doSomething(); \n    } \nBuen formato:\nif (condicion) {\n  doSomething(); \n  }"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#reducir-el-número-de-parámetros",
    "href": "Unidades/unidad6/cap6.html#reducir-el-número-de-parámetros",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.7 Reducir el Número de Parámetros",
    "text": "6.7 Reducir el Número de Parámetros\nLas funciones con muchos parámetros son difíciles de entender y usar correctamente. Intenta reducir el número de parámetros pasando objetos cuando sea posible.\nEjemplo de demasiados parámetros:\nvoid crearUsuario(String nombre, String apellido, int edad, String direccion) {\n// Crear usuario \n} \nEjemplo de uso de un objeto:\n// Main.java\n\n// Definición de la clase Usuario\nclass Usuario {\n    String nombre;\n    String apellido;\n    int edad;\n    String direccion;\n\n    // Constructor para inicializar los atributos de Usuario\n    public Usuario(String nombre, String apellido, int edad, String direccion) {\n        this.nombre = nombre;\n        this.apellido = apellido;\n        this.edad = edad;\n        this.direccion = direccion;\n    }\n\n    // Método para mostrar la información del usuario\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre);\n        System.out.println(\"Apellido: \" + apellido);\n        System.out.println(\"Edad: \" + edad);\n        System.out.println(\"Dirección: \" + direccion);\n    }\n}\n\n// Clase principal con el método crearUsuario\npublic class Main {\n\n    // Método para \"crear\" un usuario (en este caso, solo muestra la información)\n    public static void crearUsuario(Usuario usuario) {\n        System.out.println(\"Creando usuario...\");\n        usuario.mostrarInformacion();\n    }\n\n    public static void main(String[] args) {\n        // Crear una instancia de Usuario\n        Usuario usuario = new Usuario(\"Luis\", \"Jaramillo\", 30, \"Calle Falsa 123\");\n\n        // Llamar al método crearUsuario\n        crearUsuario(usuario);\n    }\n}"
  },
  {
    "objectID": "Unidades/unidad6/cap6.html#pruebas-unitarias",
    "href": "Unidades/unidad6/cap6.html#pruebas-unitarias",
    "title": "6  Nombres Claros y Descriptivos",
    "section": "6.8 Pruebas Unitarias",
    "text": "6.8 Pruebas Unitarias\nEs importante escribir pruebas unitarias para el código. Las pruebas ayudan a detectar errores y aseguran que el código funcione correctamente a medida que evoluciona.\n\nEjemplo de prueba unitaria en Java\n\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\npublic class CalculadoraTest {\n\n    @Test\n    public void testSuma() {\n        Calculadora calc = new Calculadora();\n        assertEquals(5, calc.suma(2, 3));\n    }\n}\n## [TEST](https://forms.gle/pRTgrvN2GhVDRkqw7)"
  },
  {
    "objectID": "Unidades/unidad7/cap7.html#estructura-general-de-un-programa-en-java.",
    "href": "Unidades/unidad7/cap7.html#estructura-general-de-un-programa-en-java.",
    "title": "7  Estructura General de un Programa en JAVA",
    "section": "7.1 ESTRUCTURA GENERAL DE UN PROGRAMA EN JAVA.",
    "text": "7.1 ESTRUCTURA GENERAL DE UN PROGRAMA EN JAVA.\nLa estructura general de un programa orientado a objetos depende del lenguaje de programación que se utilice, pero en general se basa en los siguientes elementos:\n\nClases: Son las plantillas o modelos que definen las propiedades y los métodos comunes de un conjunto de objetos. Las clases se pueden organizar en jerarquías mediante la herencia, que permite reutilizar y extender el código de las clases superiores a las clases inferiores.\nObjetos: Son las instancias o ejemplares de las clases, que tienen un estado (valores de los atributos) y un comportamiento (ejecución de los métodos) específicos. Los objetos se pueden comunicar entre sí mediante mensajes, que son las llamadas a los métodos de otros objetos.\nRelaciones: Son los vínculos o conexiones que existen entre las clases y los objetos, que indican cómo se relacionan o interactúan entre sí. Hay diferentes tipos de relaciones, como la asociación, la dependencia, la generalización, la realización, la agregación y la composición.\n\nVeamos paso a paso un ejemplo de un programa orientado a objetos.\nAntes de empezar, utilizaremos la imagen que utilizamos en modelamiento y se encuentra a continuación.\n\nPara el ejemplo utilizaremos el nombre de clase “Person”, están indicados los métodos y atributos en privado para mejor entendimiento cambiaremos de privado a default, por lo que el código quería así.\npublic class Person{\n  String name;  // Atributo 1\n  int birthDate; // Atributo 2\n  \n  public Person(String name, int birthDate) {  //constructor\n        this.name = name;\n        this.birthDate = birthDate;\n    }\n  \n  public void isBirthday(){    //método\n    System.out.println(\"imprimir la fecha\");\n  }\n}\nUn ejemplo más completo es el siguiente:\n// Clase Persona\npublic class Persona {\n  // Atributos\n  String nombre;\n  int edad;\n  String dni;\n\n  // Constructor\n  public Persona(String nombre, int edad, String dni) {\n    this.nombre = nombre;\n    this.edad = edad;\n    this.dni = dni;\n  }\n\n  public void saludar() {\n    System.out.println(\"Hola, me llamo \" + nombre + \" y tengo \" + edad + \" años.\");\n  }\n}\n\n// Clase Estudiante que hereda de Persona\npublic class Estudiante extends Persona {\n  // Atributos\n  public String carrera;\n  public double notaMedia;\n\n  // Constructor\n  public Estudiante(String nombre, int edad, String dni, String carrera, double notaMedia) {\n    // Llamada al constructor de la superclase\n    super(nombre, edad, dni);\n    this.carrera = carrera;\n    this.notaMedia = notaMedia;\n  }\n\n  public void estudiar() {\n    System.out.println(\"Estoy estudiando \" + carrera + \".\");\n  }\n\n  public void examinar() {\n    System.out.println(\"Me voy a examinar de \" + carrera + \".\");\n  }\n\n  // Sobrescritura del método saludar de la superclase\n  @Override\n  public void saludar() {\n    System.out.println(\"Hola, soy \" + nombre + \", estudiante de \" + carrera + \" y tengo una nota media de \" + notaMedia + \".\");\n  }\n}\n\n// Clase Profesor que hereda de Persona\npublic class Profesor extends Persona {\n  // Atributos\n  String asignatura;\n  double salario;\n\n  // Constructor\n  public Profesor(String nombre, int edad, String dni, String asignatura, double salario) {\n    // Llamada al constructor de la superclase\n    super(nombre, edad, dni);\n    this.asignatura = asignatura;\n    this.salario = salario;\n  }\n\n  public void enseñar() {\n    System.out.println(\"Estoy enseñando \" + asignatura + \".\");\n  }\n\n  public void evaluar() {\n    System.out.println(\"Voy a evaluar a mis alumnos de \" + asignatura + \".\");\n  }\n\n  // Sobrescritura del método saludar de la superclase\n  @Override\n  public void saludar() {\n    System.out.println(\"Hola, soy \" + nombre + \", profesor de \" + asignatura + \" y cobro \" + salario + \" euros al mes.\");\n  }\n}\n\n// Clase principal con el método main\npublic class Main {\n  public static void main(String[] args) {\n    // Creación de objetos\n    Persona p1 = new Persona(\"Ana\", 25, \"12345678A\");\n    Estudiante e1 = new Estudiante(\"Luis\", 20, \"87654321B\", \"Informática\", 8.5);\n    Profesor pr1 = new Profesor(\"Pedro\", 35, \"45678912C\", \"Matemáticas\", 1500);\n\n    // Llamada a los métodos de los objetos\n    p1.saludar();\n    e1.saludar();\n    pr1.saludar();\n    e1.estudiar();\n    pr1.enseñar();\n  }\n}\nTodo el código pertenece al siguiente esquema.\n\n\n\n\n\nEste programa define tres clases: Persona, Estudiante y Profesor. La clase Estudiante y la clase Profesor heredan de la clase Persona, lo que significa que comparten sus atributos y métodos, y añaden algunos propios. El programa crea tres objetos: uno de cada clase, y llama a sus métodos. El resultado es el siguiente:\nHola, me llamo Ana y tengo 25 años.\nHola, soy Luis, estudiante de Informática y tengo una nota media de 8.5.\nHola, soy Pedro, profesor de Matemáticas y cobro 1500 euros al mes.\nEstoy estudiando Informática.\nEstoy enseñando Matemáticas."
  },
  {
    "objectID": "Unidades/unidad7/cap7.html#video",
    "href": "Unidades/unidad7/cap7.html#video",
    "title": "7  Estructura General de un Programa en JAVA",
    "section": "7.2 Video",
    "text": "7.2 Video"
  },
  {
    "objectID": "Unidades/unidad8/cap8.html#introducción-a-la-entrada-y-salida-en-consola",
    "href": "Unidades/unidad8/cap8.html#introducción-a-la-entrada-y-salida-en-consola",
    "title": "8  Lectura y Escritura de Datos por Consola",
    "section": "8.1 Introducción a la Entrada y Salida en Consola",
    "text": "8.1 Introducción a la Entrada y Salida en Consola\nLa interacción por consola en Java permite a los desarrolladores capturar información ingresada por el usuario y devolver resultados o mensajes. En Java, la entrada y salida (E/S) de datos es fundamental para muchos programas, y este capítulo se centra en métodos prácticos para implementar E/S en aplicaciones de consola. A través de ejemplos prácticos, entenderás cómo utilizar las clases y métodos esenciales para obtener y mostrar información en el entorno de línea de comandos."
  },
  {
    "objectID": "Unidades/unidad8/cap8.html#entrada-de-datos",
    "href": "Unidades/unidad8/cap8.html#entrada-de-datos",
    "title": "8  Lectura y Escritura de Datos por Consola",
    "section": "8.2 Entrada de datos",
    "text": "8.2 Entrada de datos\n\n8.2.1 Clase Scanner\nLa clase Scanner es la herramienta más común para la entrada de datos en Java. Pertenece al paquete java.util y permite leer diferentes tipos de datos: cadenas, enteros, decimales y booleanos. El uso de Scanner facilita la captura de datos con el método next() para cadenas o nextInt(), nextDouble(), entre otros, para tipos específicos.\n\nEjemplo: Leer un número y un nombre\n\nimport java.util.Scanner;\n\npublic class EjemploScanner {\n    public static void main(String[] args) {\n        Scanner entrada = new Scanner(System.in);\n\n        System.out.print(\"Ingresa tu nombre: \");\n        String nombre = entrada.nextLine();\n\n        System.out.print(\"Ingresa tu edad: \");\n        int edad = entrada.nextInt();\n\n        System.out.println(\"Hola \" + nombre + \", tienes \" + edad + \" años.\");\n    }\n}\n\nnextLine(): captura una línea completa de texto, incluyendo espacios.\nnextInt(): captura un número entero.\n\nPrecaución al Leer Datos en Java\nEs importante tener cuidado al alternar la lectura de datos de diferentes tipos en Java, especialmente cuando se combinan enteros o decimales (int, float, etc.) con cadenas (String). Después de leer un valor numérico con métodos como nextInt() o nextFloat(), el buffer de entrada puede contener un salto de línea (\\n) residual. Esto puede causar que una llamada posterior a nextLine() lea dicho salto de línea en lugar de capturar la cadena esperada. Para evitar errores, se recomienda limpiar el buffer antes de leer una cadena, usando nextLine() adicionalmente.\n\n\nimport java.util.Scanner;\n\npublic class principal {\n    public static void main(String[] args) {\n        Scanner lectura = new Scanner(System.in); // 'in' significa entrada, 'out' significa salida\n        // Ejemplo de lectura de datos\n        System.out.print(\"Ingrese su nombre: \");\n        String nombre = lectura.nextLine(); // Leemos un dato tipo cadena de caracteres\n        System.out.print(\"Ingrese su edad: \");\n        int edad = lectura.nextInt(); // Leemos un dato tipo entero\n        System.out.print(\"Salario: \");\n        float salario = lectura.nextFloat();\n        // Limpiar el buffer después de leer un entero\n        lectura.nextLine();\n        System.out.print(\"Ingrese su apellido: \");\n        String apellido = lectura.nextLine();\n\n        // ¿Qué pasará si no limpiamos el buffer?\n        System.out.println(\"¿Qué pasará si no limpiamos el buffer?\");\n\n        System.out.print(\"Ingrese su nombre2: \");\n        String nombre2 = lectura.nextLine();\n        System.out.print(\"Ingrese su edad2: \");\n        int edad2 = lectura.nextInt();\n        System.out.print(\"Salario2: \");\n        float salario2 = lectura.nextFloat();\n        System.out.print(\"Ingrese su apellido: \");\n        String apellido2 = lectura.nextLine();\n        // Cerrar el scanner al finalizar\n        lectura.close();\n\n        // Ejemplo de escritura de datos\n        System.out.println(\"******************************\");\n        System.out.println(\"\\nInformación ingresada1:\");\n        System.out.println(\"Nombre: \" + nombre);\n        System.out.println(\"Apellido: \" + apellido);\n        System.out.println(\"Edad: \" + edad);\n        System.out.println(\"Salario: \" + salario);\n\n\n        System.out.println(\"******************************\");\n        System.out.println(\"\\nInformación ingresada2:\");\n        System.out.println(\"Nombre2: \" + nombre2);\n        System.out.println(\"Apellido: \" + apellido2);\n        System.out.println(\"Edad2: \" + edad2);\n        System.out.println(\"Salario2: \" + salario2);\n    }\n    \n}\n\nLimpieza de Buffer: Luego de leer int o float, se utiliza lectura.nextLine(); para limpiar el buffer antes de leer un String con nextLine().\nEvitar Errores: Al no limpiar el buffer, el programa puede no capturar la entrada del usuario como se espera y leer datos incorrectos o vacíos.\n\n\n\n8.2.2 Uso de BufferedReader\nBufferedReader es otra opción para la lectura de datos y es especialmente útil para aplicaciones que requieren un manejo eficiente de grandes volúmenes de datos. Utiliza InputStreamReader para leer desde System.in.\nEjemplo: Leer una cadena de texto\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\n\npublic class EjemploBufferedReader {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.print(\"Ingresa un mensaje: \");\n        String mensaje = reader.readLine();\n\n        System.out.println(\"Mensaje recibido: \" + mensaje);\n    }\n}\nExplicación:\n\nreadLine(): lee una línea de texto completa, ideal para capturar grandes bloques de datos."
  },
  {
    "objectID": "Unidades/unidad8/cap8.html#escritura-de-datos-en-la-consola",
    "href": "Unidades/unidad8/cap8.html#escritura-de-datos-en-la-consola",
    "title": "8  Lectura y Escritura de Datos por Consola",
    "section": "8.3 Escritura de Datos en la Consola",
    "text": "8.3 Escritura de Datos en la Consola\n\n8.3.1 Uso de System.out.println\nSystem.out.println es el método más sencillo y común para mostrar datos en la consola. Acepta texto y datos variables, permitiendo mostrar mensajes, resultados, y más.\nEjemplo: Saludo Básico\npublic class EjemploPrintln {\n    public static void main(String[] args) {\n        System.out.println(\"Bienvenido al sistema.\");\n        System.out.println(\"Este mensaje aparecerá en una nueva línea.\");\n    }\n}\nFormateo de Salida con System.out.printf\nEl método printf permite controlar el formato de la salida, especialmente útil cuando se requiere una presentación organizada de datos, como tablas o valores numéricos con un número específico de decimales.\nEjemplo: Formateo con printf\npublic class EjemploPrintf {\n    public static void main(String[] args) {\n        String producto = \"Laptop\";\n        double precio = 1234.56;\n\n        System.out.printf(\"Producto: %s, Precio: %.2f\\n\", producto, precio);\n    }\n}\n\n%s es un marcador de posición para cadenas.\n%.2f indica un número decimal con dos dígitos después del punto.\n\nEjemplo 2 : Formateo con printf\npublic class Ejemplo2Printf {\n    public static void main(String[] args) {\n        String nombre = \"Ana\";\n        int edad = 25;\n\n        System.out.printf(\"Nombre: %s, Edad: %d años\\n\", nombre, edad);\n    }\n}\nSalida esperada: Nombre: Ana, Edad: 25 años"
  },
  {
    "objectID": "Unidades/unidad9/cap9.html#introducción",
    "href": "Unidades/unidad9/cap9.html#introducción",
    "title": "9  Manejo de excepciones.",
    "section": "9.1 Introducción",
    "text": "9.1 Introducción\nEl manejo de excepciones en Java es una característica fundamental que permite gestionar errores durante la ejecución de un programa, evitando que se interrumpa abruptamente. Las excepciones representan condiciones inusuales o errores que pueden ocurrir, como intentos fallidos de abrir un archivo o la entrada de datos inválidos."
  },
  {
    "objectID": "Unidades/unidad9/cap9.html#conceptos-básicos",
    "href": "Unidades/unidad9/cap9.html#conceptos-básicos",
    "title": "9  Manejo de excepciones.",
    "section": "9.2 Conceptos Básicos",
    "text": "9.2 Conceptos Básicos\n\n9.2.1 ¿Qué es una excepción?\nUna excepción es un evento que ocurre durante la ejecución de un programa y que interrumpe el flujo normal de las instrucciones. En Java, todas las excepciones son objetos que heredan de la clase base Throwable.\nMuchas clases de errores pueden provocar una excepción, desde un desbordamiento de memoria o un disco duro estropeado, un intento de dividir por cero, o intentar acceder a un vector fuera de sus límites Cuando esto ocurre, java crea un objeto de la clase exceptión\nEjemplo:\n\npublic class EjemploExcepciones{\n  public static void main (String[] args) {\n    int num1= 2, num2=0;\n    int result=num1/num2;\n    System.out.println(\"El resultado es: \" + result);\n  }\n}\n\n\n9.2.2 Excepciones Propias de java\nAntes de continuar, se debe conocer que java error y excepción son términos relacionados con problemas que pueden ocurrir durante la ejecución de un programa, pero tienen diferencias importantes en su naturaleza y manejo:\n\n9.2.2.1 Error:\n\nUn error es un problema grave que ocurre fuera del control del programa y generalmente indica un fallo crítico del sistema o del entorno de ejecución.\n\nCaracterísticas:\n-Representado por la clase Error, que es parte del paquete java.lang.\n-No está diseñado para ser manejado por el programa.\nEn la mayoría de los casos, intentar capturar o recuperar un error es inútil.\nEjemplos comunes incluyen:\n-StackOverflowError: Cuando se desborda la pila debido a una recursión excesiva.\n-OutOfMemoryError: Cuando la JVM no tiene suficiente memoria para continuar.\nSon más relacionados con el entorno de ejecución o la configuración del sistema.\n\n\n9.2.2.2 Excepción:\nUna excepción es un problema que ocurre durante la ejecución del programa debido a errores de lógica o circunstancias excepcionales predecibles.\nRepresentada por la clase Exception, que es una subclase de Throwable, Está diseñada para ser manejada por el programa mediante bloques try-catch o con la cláusula throws.\nSe divide en dos tipos:\n-Verificadas en tiempo de compilación:\n-No Verificadas en tiempo de compilación y suelen deberse a errores de programación:\nTodos vienen de la clase throwable como se observa en la siguiente imagen.\n\n\n\n\n9.2.3 Jerarquía de Excepciones\n\nThrowable: Clase base de todas las excepciones y errores.\n\nException: Errores que pueden ser manejados por el programa.\n\nIOException: Relacionadas con operaciones de entrada/salida.\nSQLException: Errores en bases de datos.\nFileNotFoundException: Archivo no encontrado.\nArithmeticException: Errores matemáticos como división por cero.\n\nError: Condiciones críticas del sistema, como falta de memoria, que no deben manejarse directamente.\n\nEjemplos de Errores\nStackOverflowError: Este error ocurre cuando un programa utiliza demasiada memoria en la pila debido a una recursión infinita o excesiva.\n\npublic class StackOverflowExample {\n    public static void main(String[] args) {\n        recursiveMethod(); // Llamada recursiva infinita\n    }\n\n    public static void recursiveMethod() {\n        recursiveMethod(); // Llamada a sí misma sin condición de salida\n    }\n}\n\nOutOfMemoryError: Este error ocurre cuando la Java virtual machine (JVM) no tiene suficiente memoria para asignar nuevos objetos en el heap.\n\nimport java.util.ArrayList;\n\npublic class OutOfMemoryExample {\n    public static void main(String[] args) {\n        ArrayList&lt;int[]&gt; memoryHog = new ArrayList&lt;&gt;();\n        while (true) {\n            memoryHog.add(new int[1_000_000]); // Intenta llenar el heap\n        }\n    }\n}\n\n\n9.2.4 Ejemplo de Excepciones\n\nUso de throw\nEjemplo lanzando una excepción\n\n\nimport java.io.FileReader;\npublic class Throws {\n\n     public static void main(String[] args) {\n        \n        FileReader archivo = new FileReader(\"archivo_inexistente.txt\"); // Puede lanzar FileNotFoundException\n        System.out.println(\"Archivo abierto con éxito.\");\n      \n    }\n    \n}\nsaldrá el siguiente mensaje: Exception in thread “main” java.lang.RuntimeException: Uncompilable code - unreported exception java.io.FileNotFoundException; must be caught or declared to be thrown at exepciones.Exepciones.main(\nEspañol: Excepción en el hilo “main” java.lang.RuntimeException: Código no compilable - excepción no reportada java.io.FileNotFoundException; debe ser capturada o declarada para lanzarse en exepciones.Exepciones.main(\nEjemplo: Si ahora sólo lanzaramos la excepción con la palabra throws obtendríamos el siguiente mensaje.\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\n\npublic class Exepciones {\n\n    public static void main(String[] args) throws FileNotFoundException {\n        \n        FileReader archivo = new FileReader(\"archivo_inexistente.txt\"); // Puede lanzar FileNotFoundException\n        System.out.println(\"Archivo abierto con éxito.\");\n    }\n    \n}\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\n\npublic class Main {\n\n    public static void main(String[] args) throws FileNotFoundException, IOException {\n        // Intentar abrir el archivo\n        FileReader archivo = new FileReader(\"archivo_inexistente.txt\");\n        BufferedReader bufferedReader = new BufferedReader(archivo);\n\n        // Leer el archivo línea por línea\n        String linea;\n        while ((linea = bufferedReader.readLine()) != null) {\n            System.out.println(linea); // Imprime cada línea\n        }\n\n        System.out.println(\"Archivo abierto con éxito.\");\n\n        // Cerrar los recursos\n        bufferedReader.close();\n        archivo.close();\n    }\n}\nException in thread “main” java.io.FileNotFoundException: archivo_inexistente.txt (El sistema no puede encontrar el archivo especificado).\n\n\n9.2.5 Ejemplo de Excepciones Manejando TRY-CATCH-FINALLY\nEl manejo de excepciones en Java se realiza utilizando los bloques try, catch, finally, y throw. Estos permiten controlar el flujo del programa y tomar acciones específicas cuando ocurre una excepción.\n\ntry: Se utiliza para envolver el código que podría generar una excepción.\ncatch: Captura la excepción y permite tomar medidas para manejarla.\nfinally: Es un bloque opcional que se ejecuta después del try y catch, sin importar si se lanzó una excepción o no. Se usa generalmente para liberar recursos.\nthrow: Permite lanzar una excepción de manera manual.\n\nUso de try y catch\nEjemplo básico:\npublic class EjemploExcepciones {\n    public static void main(String[] args) {\n        try {\n            int resultado = 10 / 0; // Esto genera una ArithmeticException\n        } catch (ArithmeticException e) {\n            System.out.println(\"Error: División por cero.\");\n        } finally {\n            System.out.println(\"Operación finalizada.\");\n        }\n    }\n}\nSin excepción\npublic class EjemploExcepciones{\n  public static void main (String[] args) {\n    int num1= 2, num2=0;\n    int result=num1/num2;\n    System.out.println(\"El resultado es: \" + result);\n  }\n}\n\n\n9.2.6 Captura de Múltiples Excepciones:\nEn Java, es posible capturar múltiples excepciones en un mismo bloque try-catch, lo que facilita el manejo de diferentes tipos de errores en una misma sección de código. Desde Java 7, también se permite combinar varias excepciones en un solo bloque catch usando el operador |.\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        try {\n            System.out.print(\"Ingrese el numerador: \");\n            int numerador = scanner.nextInt();\n\n            System.out.print(\"Ingrese el denominador: \");\n            int denominador = scanner.nextInt();\n\n           \n            int resultado = numerador / denominador;\n            System.out.println(\"Resultado: \" + resultado);\n\n        } catch (ArithmeticException e) {\n             System.out.println(\"Error: El denominador no puede ser 0. Inténtalo de nuevo con un valor distinto.\");\n             \n        } catch (java.util.InputMismatchException e) { // java.util.InputMismatchExceptio se lanza cuando se intenta leer un tipo de dato que no coincide con el tipo esperado.\n             \n             System.out.println(\"Error: Entrada inválida. Solo se permiten números enteros.\");\n     }\n  }\n\n}\nQue pasaría ahora si se lanzara dentro de un bucle ejemplo while, para que se repita, si el usuario coloca mál el dato seguirá repitiendo la solicitud hasta tener datos correctos.\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        boolean entradaValida = false; // Bandera para controlar el bucle\n\n        while (!entradaValida) {\n            try {\n                System.out.print(\"Ingrese el numerador: \");\n                int numerador = scanner.nextInt();\n\n                System.out.print(\"Ingrese el denominador: \");\n                int denominador = scanner.nextInt();\n\n                if (denominador == 0) {\n                    throw new ArithmeticException(\"El denominador no puede ser 0.\");\n                }\n\n                int resultado = numerador / denominador;\n                System.out.println(\"Resultado: \" + resultado);\n\n                entradaValida = true; // Si llega aquí, las entradas son válidas\n\n            } catch (ArithmeticException e) {\n                System.out.println(\"Error: \" + e.getMessage());\n                scanner.nextLine(); // Limpiar el buffer de entrada\n            } catch (java.util.InputMismatchException e) {\n                System.out.println(\"Error: Entrada inválida. Solo se permiten números enteros.\");\n                scanner.nextLine(); // Limpiar el buffer de entrada\n            }\n        }\n        scanner.close();\n    }\n}\nBloque Finally\nEl bloque finally se utiliza en Java para ejecutar código que debe correr sin importar si se lanzó o no una excepción. Es útil para liberar recursos, como cerrar un objeto Scanner.\nEn este caso, podemos usar finally para garantizar que el objeto Scanner se cierre después de que el programa haya terminado de procesar las entradas.\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in); // Crear el Scanner\n\n        try {\n            boolean entradaValida = false; // Bandera para controlar el bucle\n\n            while (!entradaValida) {\n                try {\n                    System.out.print(\"Ingrese el numerador: \");\n                    int numerador = scanner.nextInt();\n\n                    System.out.print(\"Ingrese el denominador: \");\n                    int denominador = scanner.nextInt();\n\n                    if (denominador == 0) {\n                        throw new ArithmeticException(\"El denominador no puede ser 0.\");\n                    }\n\n                    int resultado = numerador / denominador;\n                    System.out.println(\"Resultado: \" + resultado);\n\n                    entradaValida = true; // Entrada válida, salir del bucle\n\n                } catch (ArithmeticException e) {\n                    System.out.println(\"Error: \" + e.getMessage());\n                    scanner.nextLine(); // Limpiar el buffer de entrada\n                } catch (java.util.InputMismatchException e) {\n                    System.out.println(\"Error: Entrada inválida. Solo se permiten números enteros.\");\n                    scanner.nextLine(); // Limpiar el buffer de entrada\n                }\n            }\n        } finally {\n            scanner.close(); // Garantiza que el recurso Scanner se cierra\n            System.out.println(\"Recurso Scanner cerrado.\");\n        }\n    }\n}\n\n\n9.2.7 Diferencias Clave entre los programas anteriores\n\n\n\n\n\n\n\n\nCaracterística\nPrimer Código (con finally)\nSegundo Código (sin finally)\n\n\n\n\nUso de finally\nUtiliza el bloque finally para garantizar el cierre del recurso Scanner.\nNo usa finally, pero cierra el recurso manualmente al final.\n\n\nLiberación de Recursos\nEl cierre del Scanner ocurre siempre, incluso si ocurre una excepción.\nEl cierre del Scanner depende de que el flujo salga del bucle correctamente.\n\n\nRobustez del Código\nMás robusto, ya que garantiza que el Scanner siempre se cierre.\nMenos robusto, podría no cerrar el recurso si ocurre un error inesperado fuera del bucle.\n\n\nLegibilidad\nSepara claramente la lógica del cierre de recursos en el bloque finally.\nAgrupa todo en el flujo principal, lo que puede ser más legible en casos simples.\n\n\n\nVideo de refuerzo\nhttps://www.youtube.com/watch?v=VHy6xFXJ1Rw"
  },
  {
    "objectID": "Unidades/unidad10/cap10.html",
    "href": "Unidades/unidad10/cap10.html",
    "title": "10  Arreglos",
    "section": "",
    "text": "Un arreglo es una estructura de datos que permite almacenar un conjunto de elementos del mismo tipo, organizados de manera contigua en memoria. Cada elemento en el arreglo puede accederse mediante un índice, comenzando desde 0.\n\n\n\n\n\n\n10.0.0.1 Características Principales de los Arreglos\n\nTipo Uniforme: Todos los elementos deben ser del mismo tipo (por ejemplo, todos enteros o todos cadenas).\nÍndices: Los elementos se identifican por su posición (índice) dentro del arreglo.\nTamaño Fijo: Los arreglos estáticos tienen un tamaño definido en el momento de su creación.\nAcceso Directo: Los elementos se pueden acceder directamente usando su índice.\n\n\n\n10.0.1 Arreglos Estáticos y Dinámicos\n\n10.0.1.1 Arreglos Estáticos\n\nDefinición: Tienen un tamaño fijo que se debe especificar en el momento de la creación.\nVentajas: Simplicidad, bajo consumo de memoria.\nDesventajas: No se pueden redimensionar una vez creados.\n\nEjemplo:\npublic class ArregloEstatico {\n    public static void main(String[] args) {\n        int[] numeros = new int[5]; // Arreglo estático de tamaño 5\n        numeros[0] = 10;\n        numeros[1] = 20;\n\n        for (int i = 0; i &lt; numeros.length; i++) {\n            System.out.println(\"Elemento en posición \" + i + \": \" + numeros[i]);\n        }\n    }\n}\n\n\n10.0.1.2 Arreglos Dinámicos\n\nDefinición: Pueden cambiar su tamaño durante la ejecución. No son arreglos directos en Java, pero pueden simularse con clases como ArrayList.\nVentajas: Flexibilidad para añadir o eliminar elementos.\nDesventajas: Uso de más memoria y procesamiento.\n\nEjemplo:\n\nimport java.util.ArrayList;\n\npublic class ArregloDinamico {\n    public static void main(String[] args) {\n        ArrayList&lt;Integer&gt; numeros = new ArrayList&lt;&gt;();\n        numeros.add(10); // Agregar elementos dinámicamente\n        numeros.add(20);\n\n        for (int numero : numeros) {\n            System.out.println(\"Elemento: \" + numero);\n        }\n    }\n}\nELEMENTOS DE UN ARREGLO.\nLos arreglos se pueden realizar de diversas maneras.\n1)\npublic class EjemploArreglo {\n    public static void main(String[] args) {\n        int[] calificaciones = {85, 90, 78, 92, 88}; // Arreglo de enteros\n\n    }\n}\n2)\n\n\n\n\n\npublic class Main\n{\n    public static void main(String[] args) {\n        \n        int[] notas = new int[7]; // Declarar arreglo de tamaño 7\n        notas[0] = 11; // Asignar valor al primer elemento\n        \n        \n    }\n}\n3\n\n\n\n\n10.0.2 Acceso e Iteración en Arreglos\nPara obtener información de un arreglo en Java, podemos acceder a sus elementos de forma individual utilizando su índice o recorrer todos los elementos mediante un bucle.\n\n10.0.2.1 Acceso Individual\nEn un arreglo, los elementos están numerados desde el índice 0. Por ejemplo, en el siguiente arreglo:\nint[] numeros = {1, 2, 3, 4, 5, 6};\n\nnumeros[0] contiene el valor 1.\nnumeros[3] contiene el valor 4.\n\nEste método es útil cuando queremos acceder a un elemento específico del arreglo.\n\n\n10.0.2.2 Recorrido Mediante Iteración\nOtra manera de trabajar con arreglos es recorriéndolos para acceder a cada uno de sus elementos. Esto se logra utilizando bucles como for o while. Esto es especialmente útil si queremos realizar operaciones sobre todos los elementos del arreglo.\nPara iterar un arreglo necesitamos dos valores clave:\n\nOrigen: El índice inicial del recorrido (generalmente 0).\nFinal: El límite del recorrido, que podemos determinar con nombre_arreglo.length. Este método devuelve la cantidad de elementos en el arreglo.\n\nint[] numeros = {10, 20, 30, 40, 50}; // Arreglo de 5 elementos\n\nfor (int i = 0; i &lt; numeros.length; i++) {\n    System.out.println(\"Elemento en posición \" + i + \": \" + numeros[i]);\n}\nla salida será\nElemento en posición 0: 10\nElemento en posición 1: 20\nElemento en posición 2: 30\nElemento en posición 3: 40\nElemento en posición 4: 50\n\n\n10.0.2.3 Uso de una Longitud Fija\nTambién podemos recorrer el arreglo con un valor de longitud fijo si sabemos cuántos elementos contiene. Aunque menos flexible, este método es útil para arreglos cuyo tamaño no cambia.\nEjemplo Manual:\nint[] numeros = {10, 20, 30, 40, 50}; // Arreglo de 5 elementos\n\nfor (int i = 0; i &lt; 5; i++) {\n    System.out.println(\"Elemento en posición \" + i + \": \" + numeros[i]);\n}\n\n\n10.0.2.4 Diferencia Entre Longitud Fija y .length\n\nCon .length: El código se adapta automáticamente al tamaño del arreglo, ideal para arreglos dinámicos.\nCon longitud fija: Es menos flexible, y cualquier cambio en el tamaño del arreglo requiere actualizar el código manualmente.\n\n\n\n10.0.2.5 Operaciones en los arrays (CRUD)\nEl término CRUD se refiere a las operaciones básicas que se pueden realizar sobre una estructura de datos:\n\nCreate (Crear): Añadir elementos al arreglo.\nRead (Leer): Acceder y leer los elementos del arreglo.\nUpdate (Actualizar): Modificar los valores de los elementos del arreglo.\nDelete (Eliminar): Quitar elementos del arreglo.\n\nEn Java, trabajar con CRUD en arreglos tiene ciertas limitaciones, ya que los arreglos tienen un tamaño fijo. A continuación, se muestran ejemplos básicos de cómo implementar estas operaciones\n\n\n10.0.2.6 Crear\nCrear un arreglo y asignar valores.\nint[] numerosEstaticos = new int[5]; // Arreglo de tamaño 5\nnumerosEstaticos[0] = 10;\nnumerosEstaticos[1] = 20;\nnumerosEstaticos[2] = 30;\nnumerosEstaticos[3] = 40;\nnumerosEstaticos[4] = 50;\n\nString[] nombresEstaticos = {\"Ana\", \"Luis\", \"María\"}; // Crear un arreglo estático de Strings\nimport java.util.ArrayList;\n\nArrayList&lt;Integer&gt; numerosDinamicos = new ArrayList&lt;&gt;();\nnumerosDinamicos.add(10); // Agregar elementos\nnumerosDinamicos.add(20);\nnumerosDinamicos.add(30);\nnumerosDinamicos.add(40);\nnumerosDinamicos.add(50);\n\nArrayList&lt;String&gt; nombresDinamicos = new ArrayList&lt;&gt;();\nnombresDinamicos.add(\"Ana\");\nnombresDinamicos.add(\"Luis\");\nnombresDinamicos.add(\"María\");\n\n\n10.0.2.7 Leer\nRecorrer un arreglo para mostrar sus elementos\nutilizando for\nfor (int i = 0; i &lt; numerosEstaticos.length; i++) {\n    System.out.println(\"Número en posición \" + i + \": \" + numerosEstaticos[i]);\n}\nutilizando for each\nfor (int numero : numerosDinamicos) {\n    System.out.println(\"Número: \" + numero);\n}\n\n\n10.0.2.8 Actualizar o Modificar\nModificar un elemento por índice.\nint[] numerosEstaticos = new int[3]; // Crear un arreglo estático de enteros\nnumerosEstaticos[0] = 10;\nnumerosEstaticos[1] = 20;\nnumerosEstaticos[1] = 25; // Cambiar el valor en la posición 1\nSystem.out.println(\"Número actualizado: \" + numerosEstaticos[1]);\nimport java.util.ArrayList;\n\nArrayList&lt;Integer&gt; numerosDinamicos = new ArrayList&lt;&gt;();\nnumerosDinamicos.add(10); // Agregar elementos\nnumerosDinamicos.add(20);\nnumerosDinamicos.add(30);\nnumerosDinamicos.add(40);\nnumerosDinamicos.add(50);\nnumerosDinamicos.set(1, 25); // Cambiar el valor en la posición 1\nSystem.out.println(\"Número actualizado: \" + numerosDinamicos.get(1));\n\n\n10.0.2.9 Eliminar\n\n\n10.0.2.10 Arreglo Estático\nNo es posible eliminar directamente, pero puedes sobrescribir con un valor nulo o crear un nuevo arreglo.\nnumerosEstaticos[1] = 0; // Sobrescribir el valor en la posición 1\nSystem.out.println(\"Número en posición 1 eliminado: \" + numerosEstaticos[1]);\n\nnombresEstaticos[1] = null; // Sobrescribir con null\nSystem.out.println(\"Nombre en posición 1 eliminado: \" + nombresEstaticos[1]);\n\n\n10.0.2.11 Arreglo Dinámico\nUsar el método remove para eliminar un elemento.\nnumerosDinamicos.remove(1); // Eliminar el elemento en la posición 1\nSystem.out.println(\"ArrayList después de eliminar: \" + numerosDinamicos);\n\nnombresDinamicos.remove(1); // Eliminar el elemento en la posición 1\nSystem.out.println(\"ArrayList después de eliminar: \" + nombresDinamicos);\nEjemplo completo\nimport java.util.ArrayList;\n\npublic class CRUDExample {\n    public static void main(String[] args) {\n        // Crear (Create)\n        int[] numerosEstaticos = {10, 20, 30};\n        ArrayList&lt;String&gt; nombresDinamicos = new ArrayList&lt;&gt;();\n        nombresDinamicos.add(\"Ana\");\n        nombresDinamicos.add(\"Luis\");\n        nombresDinamicos.add(\"María\");\n\n        // Leer (Read)\n        System.out.println(\"Arreglo Estático:\");\n        for (int i = 0; i &lt; numerosEstaticos.length; i++) {\n            System.out.println(\"Número: \" + numerosEstaticos[i]);\n        }\n\n        System.out.println(\"\\nArreglo Dinámico:\");\n        for (String nombre : nombresDinamicos) {\n            System.out.println(\"Nombre: \" + nombre);\n        }\n\n        // Actualizar (Update)\n        numerosEstaticos[1] = 25; // Actualizar arreglo estático\n        nombresDinamicos.set(1, \"Carlos\"); // Actualizar ArrayList\n        System.out.println(\"\\nActualizado:\");\n        System.out.println(\"Número estático en posición 1: \" + numerosEstaticos[1]);\n        System.out.println(\"Nombre dinámico en posición 1: \" + nombresDinamicos.get(1));\n\n        // Eliminar (Delete)\n        nombresDinamicos.remove(1); // Eliminar del ArrayList\n        System.out.println(\"\\nDespués de eliminar:\");\n        for (String nombre : nombresDinamicos) {\n            System.out.println(\"Nombre: \" + nombre);\n        }\n    }\n}\nEjemplo Práctico\nLogin\nimport java.util.Scanner;\n\npublic class LoginArray {\n    public static void main(String[] args) {\n        // Arreglos para usuarios y contraseñas\n        String[] usuarios = {\"admin\", \"usuario1\", \"usuario2\"};\n        String[] contraseñas = {\"admin123\", \"clave1\", \"clave2\"};\n\n        // Variables para capturar el login\n        Scanner scanner = new Scanner(System.in);\n        System.out.print(\"Ingrese su usuario: \");\n        String usuarioIngresado = scanner.nextLine();\n        System.out.print(\"Ingrese su contraseña: \");\n        String contraseñaIngresada = scanner.nextLine();\n\n        // Validar el login\n        boolean accesoPermitido = false;\n        \n        for (int i = 0; i &lt; usuarios.length; i++) {\n          \n            if (usuarios[i].equals(usuarioIngresado) && contraseñas[i].equals(contraseñaIngresada)) {\n                accesoPermitido = true;\n                break;\n            }\n        }\n\n        // Mostrar resultado\n        if (accesoPermitido) {\n            System.out.println(\"¡Acceso permitido! Bienvenido, \" + usuarioIngresado);\n        } else {\n            System.out.println(\"Usuario o contraseña incorrectos. Inténtelo de nuevo.\");\n        }\n\n        // Cerrar el Scanner\n        scanner.close();\n    }\n}\n\n\n\n10.0.3 Introducción a los Arreglos de Objetos\nEn Java, un arreglo de objetos es una estructura que almacena múltiples instancias de una clase en una única colección. A diferencia de los arreglos de tipos primitivos (como int o double), un arreglo de objetos contiene referencias a instancias de una clase personalizada, lo que permite organizar y manipular datos más complejos.\nPor ejemplo, si trabajas con un objeto Persona que tiene atributos como nombre, edad y correo, puedes usar un arreglo para almacenar múltiples personas y acceder a sus datos de manera estructurada.\n\n\n10.0.4 Características de los Arreglos de Objetos\n\nCapacidad para Almacenar Múltiples Instancias: Permiten trabajar con un grupo de objetos relacionados.\nHomogeneidad: Todos los elementos del arreglo deben ser del mismo tipo (la misma clase).\nAcceso Mediante Índices: Los objetos en el arreglo se acceden a través de índices, comenzando desde 0.\n\n\n\n10.0.5 Ejemplo: Objeto Persona con 3 Atributos\n\n10.0.5.1 Clase Persona\nLa clase Persona tiene los atributos nombre, edad y correo.\nCódigo:\nclass Persona {\n    // Atributos públicos\n    public String nombre;\n    public int edad;\n    public String correo;\n\n    // Constructor\n    public Persona(String nombre, int edad, String correo) {\n        this.nombre = nombre;\n        this.edad = edad;\n        this.correo = correo;\n    }\n\n    // Método para mostrar información de la persona\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad + \", Correo: \" + correo);\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        // Crear un arreglo de objetos Persona\n        Persona[] personas = new Persona[3];\n\n        // Inicializar los objetos dentro del arreglo\n        personas[0] = new Persona(\"Ana\", 25, \"ana@example.com\");\n        personas[1] = new Persona(\"Luis\", 30, \"luis@example.com\");\n        personas[2] = new Persona(\"María\", 22, \"maria@example.com\");\n\n        // Recorrer el arreglo y mostrar la información de cada Persona\n        for (int i = 0; i &lt; personas.length; i++) {\n            personas[i].mostrarInformacion();\n        }\n\n        // Modificar un atributo directamente\n        personas[1].nombre = \"Luis Alberto\";\n        personas[1].edad = 31;\n        personas[1].correo = \"luis.alberto@example.com\";\n\n        System.out.println(\"\\nInformación actualizada:\");\n        personas[1].mostrarInformacion();\n    }\n}\nimport java.util.ArrayList;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Crear un ArrayList dinámico de objetos Persona\n        ArrayList&lt;Persona&gt; personas = new ArrayList&lt;&gt;();\n\n        // Agregar objetos Persona al ArrayList\n        personas.add(new Persona(\"Ana\", 25, \"ana@example.com\"));\n        personas.add(new Persona(\"Luis\", 30, \"luis@example.com\"));\n        personas.add(new Persona(\"María\", 22, \"maria@example.com\"));\n\n        // Recorrer el ArrayList y mostrar la información de cada Persona\n        for (Persona persona : personas) {\n            persona.mostrarInformacion();\n        }\n\n        // Modificar un objeto directamente en el ArrayList\n        personas.get(1).nombre = \"Luis Alberto\";\n        personas.get(1).edad = 31;\n        personas.get(1).correo = \"luis.alberto@example.com\";\n\n        System.out.println(\"\\nInformación actualizada:\");\n        personas.get(1).mostrarInformacion();\n\n        // Eliminar un objeto del ArrayList\n        personas.remove(0);\n\n        System.out.println(\"\\nLista después de eliminar a Ana:\");\n        for (Persona persona : personas) {\n            persona.mostrarInformacion();\n        }\n    }\n}"
  },
  {
    "objectID": "Unidades/unidad11/cap11.html",
    "href": "Unidades/unidad11/cap11.html",
    "title": "11  Encapsulamiento",
    "section": "",
    "text": "El encapsulamiento es uno de los pilares fundamentales de la Programación Orientada a Objetos (POO). Se refiere a la capacidad de ocultar los detalles internos de un objeto y exponer solo lo necesario para su funcionamiento. Esto asegura que los datos del objeto estén protegidos de accesos no autorizados y se gestionen a través de métodos controlados.\n\n11.0.0.1 Objetivos de Aprendizaje\nAl finalizar esta lección, los estudiantes podrán:\n\nComprender el concepto de encapsulamiento y su importancia en POO.\nImplementar encapsulamiento en Java utilizando modificadores de acceso.\nDiseñar clases con atributos privados y métodos públicos (getters y setters).\nAnalizar casos prácticos que demuestren la ventaja del encapsulamiento.\n\n\n\n11.0.1 Concepto de Encapsulamiento\nDefinición:\nEl encapsulamiento consiste en ocultar los atributos de una clase (haciéndolos privados) y proporcionar acceso a ellos mediante métodos públicos específicos llamados getters (obtener) y setters (establecer).\npublic class Persona {\n    // Atributos privados (ocultos)\n    private String nombre;\n    private int edad;\n\n    // Métodos públicos para acceder a los atributos\n    public String getNombre() {\n        return nombre;\n    }\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    public void setEdad(int edad) {\n        if (edad &gt; 0) { // Validación básica\n            this.edad = edad;\n        } else {\n            System.out.println(\"La edad debe ser positiva.\");\n        }\n    }\n}\n\n\n11.0.2 Modificadores de Acceso\nJava ofrece diferentes modificadores de acceso para controlar la visibilidad de atributos y métodos:\n\n\n\n11.0.3 Beneficios del Encapsulamiento\n\nSeguridad: Protege los datos de modificaciones no deseadas.\nControl: Permite agregar reglas o validaciones al acceso de datos.\nFlexibilidad: Facilita cambios internos en la clase sin afectar al resto del programa.\nModularidad: Promueve un diseño más claro y organizado.\n\n\n\n11.0.4 Implementación de Encapsulamiento en Java\n\n11.0.4.1 Pasos para implementar encapsulamiento:\n\nDeclarar los atributos de la clase como private.\nCrear métodos públicos get y set para acceder y modificar los atributos.\nOpcionalmente, agregar validaciones o lógica en los métodos set.\n\nEjemplo con validaciones:\npublic class CuentaBancaria {\n    private double saldo;\n\n    public double getSaldo() {\n        return saldo;\n    }\n  \n//método depositar\n\n    public void depositar(double cantidad) {\n        if (cantidad &gt; 0) {\n            saldo += cantidad;\n        } else {\n            System.out.println(\"La cantidad debe ser positiva.\");\n        }\n    }\n\n//método retirar\n    public void retirar(double cantidad) {\n        if (cantidad &gt; 0 && cantidad &lt;= saldo) {\n            saldo -= cantidad;\n        } else {\n            System.out.println(\"Operación inválida. Fondos insuficientes o cantidad negativa.\");\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        CuentaBancaria cuenta = new CuentaBancaria();\n\n        // Depósito\n        cuenta.depositar(500);\n        System.out.println(\"Saldo después del depósito: \" + cuenta.getSaldo());\n\n        // Retiro válido\n        cuenta.retirar(200);\n        System.out.println(\"Saldo después del retiro: \" + cuenta.getSaldo());\n\n        // Intento de retiro inválido\n        cuenta.retirar(1000);\n    }\n}\n\n\n\n11.0.5 Aplicaciones Prácticas del Encapsulamiento\n\n11.0.5.1 Caso Práctico 1: Gestión de estudiantes\nDesarrolla una clase Estudiante que almacene el nombre, la matrícula y el promedio del estudiante. Asegúrate de que:\n\nEl promedio esté siempre entre 0 y 10.\nEl número de matrícula no pueda modificarse una vez establecido.\n\n\n\n11.0.5.2 Solución:\npublic class Persona {\n    private String nombre;\n    private int edad;\n\n    // Constructor público usa los setters\n    public Persona(String nombre, int edad) {\n        setNombre(nombre); // Usa el setter para inicializar con validación\n        setEdad(edad);     // Usa el setter para inicializar con validación\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public void setNombre(String nombre) {\n        if (nombre != null && !nombre.isEmpty()) {\n            this.nombre = nombre;\n        } else {\n            throw new IllegalArgumentException(\"El nombre no puede ser nulo o vacío.\");\n        }\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    public void setEdad(int edad) {\n        if (edad &gt; 0) {\n            this.edad = edad;\n        } else {\n            throw new IllegalArgumentException(\"La edad debe ser positiva.\");\n        }\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n       \n          \n            Persona persona1 = new Persona(\"Juan Pérez\", 25);\n            System.out.println(\"Persona creada: \" + persona1.getNombre() + \", \" + persona1.getEdad() + \" años\");\n\n            // Modificar los atributos usando los setters\n            persona1.setNombre(\"Ana López\");\n            persona1.setEdad(30);\n            System.out.println(\"Nombre actualizado: \" + persona1.getNombre());\n            System.out.println(\"Edad actualizada: \" + persona1.getEdad());\n\n         \n    }\n}\n\n\n\n11.0.6 Datos Inmutables\nLos datos inmutables son aquellos cuyo estado no puede cambiar después de su creación. En la Programación Orientada a Objetos (POO), las clases inmutables son especialmente útiles porque proporcionan seguridad, simplicidad y consistencia. Al diseñar una clase inmutable, garantizamos que sus atributos no puedan ser modificados una vez que se han inicializado.\nUn dato o clase es inmutable si:\n\nSus atributos no pueden ser modificados después de ser inicializados.\nNo se proporcionan métodos que permitan cambiar el estado del objeto (como setters).\nEl acceso a los atributos se realiza de manera controlada, generalmente a través de getters.\n\n\n\n11.0.7 Uso de final con Variables\nCuando declaras una variable como final, su valor no puede cambiar después de ser inicializado. Esto es muy útil para garantizar que ciertos datos permanezcan constantes durante la ejecución del programa.\npublic class EjemploFinalVariable {\n    public static void main(String[] args) {\n        final int constante = 10; // Declaración de una variable final\n        System.out.println(\"Valor de constante: \" + constante);\n\n        // constante = 20; // Esto genera un error de compilación: no se puede modificar\n    }\n}\n\n\n11.0.8 Uso de final con Métodos\nCuando un método es declarado como final, significa que no puede ser sobrescrito en clases que heredan de la clase donde se define el método.\nclass Padre {\n    public final void metodoFinal() {\n        System.out.println(\"Este método no puede ser sobrescrito.\");\n    }\n}\n\nclass Hijo extends Padre {\n    // public void metodoFinal() {\n    //     Esto generaría un error de compilación porque el método es final.\n    // }\n}\n\n\n11.0.9 Uso de final con Clases\nCuando una clase es declarada como final, significa que no puede ser extendida (heredada) por otras clases.\npublic final class ClaseFinal {\n    public void metodo() {\n        System.out.println(\"Esta clase no puede ser extendida.\");\n    }\n}\n\n// class SubClase extends ClaseFinal { \n//     Esto generaría un error porque ClaseFinal es final y no se puede heredar.\n// }\n\n\n11.0.10 Uso de final con Atributos de Clase\nCuando declaras un atributo de clase como final, garantiza que solo puede ser asignado una vez, ya sea en su declaración o dentro del constructor.\nEjemplo\npublic class Persona {\n    private final String nombre; // Atributo final: inmutable\n    private final int edad;      // Atributo final: inmutable\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre; // Se asigna en el constructor\n        this.edad = edad;     // Se asigna en el constructor\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    // No hay setters porque no pueden cambiarse los valores de los atributos finales.\n}\n\n\n11.0.11 Ejercicio Práctico\nInstrucciones:\n\nCrea una clase Libro con los atributos:\n\ntitulo (tipo String).\nautor (tipo String).\nisbn (tipo String).\n\nAsegúrate de que todos los atributos sean inmutables.\nProporciona un constructor para inicializar los valores y métodos getter para acceder a ellos.\nEn la clase Main, crea al menos dos objetos Libro y muestra sus datos por consola."
  },
  {
    "objectID": "Unidades/unidad12/cap12.html",
    "href": "Unidades/unidad12/cap12.html",
    "title": "12  Constructores",
    "section": "",
    "text": "En Java, un constructor es un bloque de código especial que se ejecuta automáticamente cuando se crea un objeto de una clase. Su propósito principal es inicializar los atributos del objeto. A diferencia de los métodos comunes, el constructor:\nTiene el mismo nombre que la clase. No tiene un tipo de retorno, ni siquiera void.\n\n12.0.1 Definición y Función\nEl constructor se utiliza para:\n\nAsignar valores iniciales a los atributos de una clase.\nGarantizar que un objeto tenga un estado válido desde el momento de su creación.\n\nEjemplo\npublic class Persona {\n    public String nombre;\n    public int edad;\n\n    // Constructor\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n}\n\n\n12.0.2 Tipos de Constructores\n\n12.0.2.1 a. Constructor por Defecto\nUn constructor por defecto es un constructor sin parámetros que no se define explícitamente. Si no escribes ningún constructor, el compilador genera uno automáticamente.\n\n\n12.0.2.2 Ejemplo:\n\npublic class Persona {\n    public String nombre;\n    public int edad;\n\n    // Constructor por defecto generado automáticamente (sin parámetros)\n}\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona();\n        persona.nombre(\"Luis\");\n        persona.edad(23);\n    }\n}\n\n\n12.0.2.3 b. Constructor Parametrizado\nUn constructor parametrizado permite inicializar los atributos del objeto con valores específicos.\n\n\n12.0.2.4 Ejemplo:\npublic class Persona {\n    public String nombre;\n    public int edad;\n\n    // Constructor parametrizado\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona(\"Juan Pérez\", 30);\n        persona.mostrarInformacion();\n    }\n}\n\n\n12.0.2.5 c. Sobrecarga de Constructores\nJava permite definir múltiples constructores en la misma clase, siempre que tengan diferentes listas de parámetros (número o tipo de parámetros). Esto se llama sobrecarga de constructores.\n\n\n12.0.2.6 Ejemplo:\npublic class Persona {\n    public String nombre;\n    public int edad;\n\n    // Constructor vacio\n    public Persona() {\n        this.nombre = \"Desconocido\";\n        this.edad = 0;\n    }\n\n    // Constructor parametrizado\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona1 = new Persona(); // Llama al constructor por defecto\n        Persona persona2 = new Persona(\"Ana López\", 25); // Llama al constructor parametrizado\n\n        persona1.mostrarInformacion();\n        persona2.mostrarInformacion();\n    }\n}\n\n\n12.0.2.7 d. Constructor copia.\nUn constructor copia es un tipo especial de constructor que crea un nuevo objeto como una copia exacta de otro objeto existente de la misma clase. Es útil cuando deseas duplicar un objeto sin modificar el original, manteniendo la separación entre las instancias.\nEl constructor copia toma un objeto de la misma clase como parámetro y copia los valores de sus atributos al nuevo objeto.\n\n\n\n12.0.3 Ventajas del Constructor Copia\n\nFacilita la Clonación:\n\nPermite duplicar objetos sin necesidad de escribir métodos adicionales.\n\nEncapsulamiento:\n\nCopia los atributos directamente sin exponerlos al exterior.\n\nSeparación de Instancias:\n\nEl objeto copiado es independiente del original, incluso si tienen los mismos valores.\n\n\nCómo funciona\nutiliza la siguiente línea de comando para crear un objeto copia\nPersona personaCopia = new Persona(personaOriginal);\n\nCrea un nuevo objeto personaCopia\nPasa personaOriginal como argumento al constructor copia:\n\nEl objeto personaOriginal se pasa como parámetro al constructor copia, permitiendo que se acceda a sus atributos y se copien en el nuevo objeto personaCopia.\n\nAsignación de nombre en el constructor Copia:\n\nEn la línea this.nombre = otraPersona.nombre;\natributo nombre del objeto otraPersona es personaOriginal\nComo el atributo nombre es private, puedes acceder a él directamente dentro de la misma clase porque las reglas de encapsulamiento lo permiten\nAsigna el valor de otraPersona.nombre a this.nombre, copiando el valor del atributo del objeto original al nuevo objeto.\n\n\n\n12.0.3.1 Ejemplo:\npublic class Persona {\n    private String nombre; // Nombre de la persona\n    private int edad;      // Edad de la persona\n\n    // Constructor parametrizado\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    // Constructor copia\n    public Persona(Persona otraPersona) {\n        this.nombre = otraPersona.nombre;\n        this.edad = otraPersona.edad;\n    }\n\n    // Métodos getter\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    // Método setter para modificar el nombre\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // Método para mostrar información\n    public void mostrarInformacion() {\n        System.out.println(\"Nombre: \" + nombre + \", Edad: \" + edad);\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        // Crear un objeto original\n        Persona personaOriginal = new Persona(\"Juan Pérez\", 30);\n        System.out.println(\"Información de la persona original:\");\n        personaOriginal.mostrarInformacion();\n\n        // Crear una copia del objeto usando el constructor copia\n        Persona personaCopia = new Persona(personaOriginal);\n        System.out.println(\"Información de la persona copia:\");\n        personaCopia.mostrarInformacion();\n\n        // Modificar el nombre de la copia\n        System.out.println(\"Modificando el nombre de la copia...\");\n        personaCopia.setNombre(\"Ana López\");\n\n        // Mostrar la información después de la modificación\n        System.out.println(\"Información después de la modificación:\");\n        System.out.println(\"Original:\");\n        personaOriginal.mostrarInformacion(); // Original permanece igual\n        System.out.println(\"Copia:\");\n        personaCopia.mostrarInformacion();    // La copia tiene el nuevo nombre\n    }\n}"
  },
  {
    "objectID": "Unidades/unidad13/cap13.html",
    "href": "Unidades/unidad13/cap13.html",
    "title": "13  Persistencia",
    "section": "",
    "text": "La persistencia de datos es el proceso de almacenar información para que permanezca disponible incluso después de que finaliza la ejecución de un programa. En Java, la persistencia se puede implementar utilizando diversos métodos como: - archivos - bases de datos - frameworks avanzados como Hibernate.\nEsta unidad se enfoca en los fundamentos de la persistencia, utilizando archivos como medio para almacenar y recuperar información.\nObjetivos de Aprendizaje - Entender qué es la persistencia de datos y por qué es importante. - Aprender a escribir y leer datos desde un archivo utilizando Java. - Conocer las diferencias entre persistencia en texto y persistencia binaria. - Introducir el concepto de serialización para manejar objeto\n\n13.0.0.1 Métodos de Persistencia en Java\nDentro de los métodos en los cuales se puede realizar la persistencia son:\n\nArchivos de Texto: Los datos se almacenan en formato legible para los humanos, contiene información estructurada simple, utilizada comúnmente para configuraciones o logs.\n\nArchivos Binarios: Los datos se almacenan en formato binario, lo que es más eficiente pero no legible para los humanos, Útil para manejar grandes cantidades de datos o estructuras complejas.\n\nBases de Datos: Los datos se almacenan y administran usando sistemas de gestión de bases de datos (SQL o NoSQL). Útil para aplicaciones empresariales o de gran escala.\n\nSerialización: La serialización es un proceso mediante el cual podemos convertir objetos de un programa en ejecución en flujos de bytes capaces de ser almacenados en dispositivos, bases de datos o de ser enviados a través de la red y, posteriormente, ser capaces de reconstruirlos en los equipos donde sea necesario.\n\n\n\n\n\n\n\n\n13.0.0.2 Ejemplo de Persistencia con Archivos de Texto\nPara la escritura de archivo se hace uso de las librerías java.io.FileWriter , al utilizar la persistencia de datos se hace uso de una excepción verificada por ende es necesario impotar la librería java.io.IOException.\nUna vez importado las librerías instanciamos un objeto de la clase FileWriter con el siguiente comando\nFileWriter escritor = new FileWriter(\"datos.txt\")\npara escribir la información del documento hacemos uso de la línea\nescritor.write(datos);\nEstructura del código\nlibrerías\n\n public class Main{\n   public static void main (String[] args) {\n     String información = \"Información que el archivo contiene\";\n     \n     try(FileWriter escritor = new FileWriter(\"datos.txt\")){\n       escritor.write(datos);\n       System.out.println(\"Datos escritos correctamente.\");\n       \n     }catch(IOException e){\n       System.out.println(\"el error es:\" + e);\n       \n     }\n     \n   }\n   \n   \n }\nporqué FileWriter escritor = new FileWriter(“datos.txt”), está dentro del try?\nEl bloque try-with-resources permite declarar y usar recursos que necesitan ser cerrados automáticamente al finalizar el bloque try. Un recurso es cualquier objeto que implementa la interfaz AutoCloseable, como FileWriter, BufferedReader, FileOutputStream, etc.\nCuando usas un recurso dentro de los paréntesis del try, Java se asegura de cerrarlo automáticamente al salir del bloque, independientemente de si ocurre una excepción o no. Esto elimina la necesidad de cerrar manualmente el recurso con un finally.\nquedando un código final como el siguiente:\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class EscribirArchivo {\n    public static void main(String[] args) {\n        String datos = \"Nombre: Juan Pérez\\nEdad: 30\\nOcupación: Ingeniero\";\n\n        try (FileWriter escritor = new FileWriter(\"datos.txt\")) {\n            escritor.write(datos);\n            System.out.println(\"Datos escritos correctamente.\");\n        } catch (IOException e) {\n            System.out.println(\"Error al escribir el archivo: \" + e.getMessage());\n        }\n    }\n}\nEjemplo 2\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class EscribirArchivo {\n    public static void main(String[] args) {\n        // Texto extenso con saltos de línea\n        String resumen = \"El lenguaje de programación Java es una de las tecnologías más utilizadas\\n\"\n                + \"en el desarrollo de aplicaciones, tanto en la industria como en la academia.\\n\"\n                + \"Es conocido por su portabilidad, robustez y soporte para la programación\\n\"\n                + \"orientada a objetos, lo que lo convierte en una opción ideal para una amplia\\n\"\n                + \"variedad de proyectos, desde aplicaciones empresariales hasta videojuegos.\";\n\n        try (FileWriter escritor = new FileWriter(\"resumen.txt\")) {\n            escritor.write(resumen);\n            System.out.println(\"Resumen escrito correctamente en el archivo.\");\n        } catch (IOException e) {\n            System.out.println(\"Error al escribir en el archivo: \" + e.getMessage());\n        }\n    }\n}\n\n\n13.0.0.3 Leer Datos desde un Archivo\nPara leer datos de un archivo hacemos uso de las siguientes librerías:\n\nBufferedReader: Esta librería que utilizamos en el módulo 8 de la lectura y escritura de datos por consola nos permite leer una gran cantidad de datos y grabarlos en una variable.\nFileReader: Leer las líneas de un archivo.\nIOException: Permite manejar excepciones ya que si recordamos la manipulación de archivos son excepciones verificadas por lo que hay que indicar que sucedería en caso que no exísta el archivo que queremos leer.\n\nPara leer un archivo, necesitamos instanciar la clase BufferedReader, a la cual le pasaremos como parámetro un objeto de tipo FileReader, indicando el archivo que queremos leer. Esto se logra con el siguiente comando:\ntry (BufferedReader lector = new BufferedReader(new FileReader(\"datos.txt)))\nEl código anterior nos permite leer la primera línea del archivo. Para leer todas las líneas del documento, es necesario utilizar un bucle que recorra el archivo hasta el final, imprimiendo cada línea. Esto se logra con el siguiente fragmento:\nString linea;\nwhile ((linea = lector.readLine()) != null) {\n    System.out.println(linea);\n}\nQuedando como resultado el siguiente código.\nimport java.io.FileReader;\nimport java.io.BufferedReader;\nimport java.io.IOException;\n\npublic class LeerArchivo {\n    public static void main(String[] args) {\n        try (BufferedReader lector = new BufferedReader(new FileReader(\"datos.txt\"))) {\n            String linea;\n            while ((linea = lector.readLine()) != null) {\n                System.out.println(linea);\n            }\n        } catch (IOException e) {\n            System.out.println(\"Error al leer el archivo: \" + e.getMessage());\n        }\n    }\n}\n\n\n13.0.0.4 Serialización\nLa serialización es el proceso de convertir un objeto en una secuencia de bytes. Este proceso permite almacenar el estado de un objeto en un archivo, base de datos u otro medio, o transmitirlo a través de una red. Posteriormente, mediante la deserialización, se puede reconstruir el objeto original a partir de esos bytes.\n\n\n13.0.0.5 ¿Para Qué Sirve?\n\nPersistencia: Guardar el estado de un objeto para su uso posterior.\nTransmisión de Datos: Enviar objetos a través de redes, por ejemplo, en aplicaciones cliente-servidor.\nClonación: Crear copias exactas de objetos.\n\n\n\n13.0.1 Librerías Necesarias\nPara implementar serialización en Java, usaremos las siguientes librerías estándar:\n\njava.io.Serializable\n\nEsta es una interfaz de marcado, lo que significa que no tiene métodos. Simplemente indica que una clase puede ser serializada.\nTodas las clases que desees serializar deben implementarla.\n\njava.io.FileOutputStream\n\nEsta clase se utiliza para escribir datos en un archivo.\nEn el contexto de la serialización, sirve como flujo base para guardar los bytes serializados en un archivo.\n\njava.io.ObjectOutputStream\n\nPermite convertir un objeto en una secuencia de bytes y escribirlo en un flujo de salida (como un archivo o un socket).\nEs esencial para realizar la serialización de objetos.\n\njava.io.FileInputStream\n\nEsta clase permite leer datos desde un archivo.\nEn el contexto de la deserialización, sirve como flujo base para leer los bytes del archivo donde se guardó el objeto.\n\njava.io.ObjectInputStream\n\nPermite convertir una secuencia de bytes en un objeto y reconstruir su estado original.\nEs esencial para realizar la deserialización de objetos.\n\njava.io.IOException\n\nExcepción lanzada cuando ocurre un error de entrada/salida, como cuando el archivo no existe o no puede ser leído.\n\njava.lang.ClassNotFoundException\n\nExcepción lanzada durante la deserialización si la clase del objeto no se encuentra en el entorno de ejecución.\n\n\n\n\n13.0.2 Descripción de las Líneas del Código\n\n13.0.2.1 Serialización\ntry (FileOutputStream fileOut = new FileOutputStream(\"persona.ser\");\n     ObjectOutputStream out = new ObjectOutputStream(fileOut)) {\n\n//  FileOutputStream:Abre o crea un archivo llamado persona.ser para escribir los datos serializados.\n// ObjectOutputStream: Convierte el objeto en una secuencia de bytes y lo guarda en el archivo persona.ser.\nout.writeObject(persona);\n//Serializa el objeto persona y lo guarda en el archivo.\n\n\n13.0.2.2 Deserialización\ntry (FileInputStream fileIn = new FileInputStream(\"persona.ser\");\n     ObjectInputStream in = new ObjectInputStream(fileIn)) {\n// FileInputStream:Abre el archivo persona.ser para leer los datos.\n//ObjectInputStream:Reconstruye el objeto desde la secuencia de bytes leída del archivo.\nPersona persona = (Persona) in.readObject();\n// Lee los bytes del archivo y los convierte de nuevo en un objeto.\n//(Persona): Realiza un cast para convertir el objeto leído a su tipo original (Persona).\n\n\n\n13.0.3 Código Completo\n\n13.0.3.1 Clase Persona\nimport java.io.Serializable;\n\npublic class Persona implements Serializable {\n    private String nombre;\n    private int edad;\n\n    // Constructor\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    // Métodos Getter\n    public String getNombre() {\n        return nombre;\n    }\n\n    public int getEdad() {\n        return edad;\n    }\n\n    // Método toString para mostrar el objeto en texto legible\n    @Override\n    public String toString() {\n        return \"Nombre: \" + nombre + \", Edad: \" + edad;\n    }\n}\n\n\n13.0.3.2 Serialización\nimport java.io.FileOutputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.IOException;\n\npublic class SerializarPersona {\n    public static void main(String[] args) {\n        // Crear un objeto Persona\n        Persona persona = new Persona(\"Juan Pérez\", 30);\n\n        // Serializar el objeto a un archivo\n        try (FileOutputStream fileOut = new FileOutputStream(\"persona.ser\");\n             ObjectOutputStream out = new ObjectOutputStream(fileOut)) {\n\n            // Escribir el objeto persona en el archivo\n            out.writeObject(persona);\n            System.out.println(\"El objeto ha sido serializado y guardado en persona.ser\");\n\n        } catch (IOException e) {\n            System.out.println(\"Error al serializar el objeto: \" + e.getMessage());\n        }\n    }\n}\n\n\n13.0.3.3 Deserialización\nimport java.io.FileInputStream;\nimport java.io.ObjectInputStream;\nimport java.io.IOException;\nimport java.lang.ClassNotFoundException;\n\npublic class DeserializarPersona {\n    public static void main(String[] args) {\n        // Deserializar el objeto desde el archivo\n        try (FileInputStream fileIn = new FileInputStream(\"persona.ser\");\n             ObjectInputStream in = new ObjectInputStream(fileIn)) {\n\n            // Leer el objeto del archivo\n            Persona persona = (Persona) in.readObject();\n            System.out.println(\"El objeto deserializado es:\");\n            System.out.println(persona);\n\n        } catch (IOException e) {\n            System.out.println(\"Error al deserializar el objeto: \" + e.getMessage());\n        } catch (ClassNotFoundException e) {\n            System.out.println(\"Clase no encontrada: \" + e.getMessage());\n        }\n    }\n}\n\n\n\n13.0.4 Main\n\n\n13.0.5 Salida Esperada\nSerialización: El objeto ha sido serializado y guardado en persona.ser\nDeserialización:\nEl objeto deserializado es: Nombre: Juan Pérez, Edad: 30"
  },
  {
    "objectID": "Unidades/unidad14/cap14.html",
    "href": "Unidades/unidad14/cap14.html",
    "title": "14  Relación entre Clases en Java",
    "section": "",
    "text": "Las relaciones entre clases en Java muestran cómo se conectan e interactúan dos o más clases. Estas relaciones reflejan situaciones del mundo real y ayudan a que las clases trabajen juntas, compartiendo información y funcionalidades.\nEjemplo\nUna Persona vive en una Casa.\nUna factura pertenece a un Cliente\nEn estos casos, las clases Persona, Casa, Factura y Cliente necesitan “hablarse” para representar estas relaciones del mundo real.\nCuando modelamos relaciones entre clases en Java, es útil entender cómo interactúan las entidades en el mundo real. Estas relaciones pueden ser:\n\nDe Uno a Uno: Una entidad está relacionada con otra exclusivamente.\nEjemplo: Una persona tiene un pasaporte.\nDe Uno a Muchos: Una entidad está relacionada con varias.\nEjemplo: Un maestro enseña a muchos estudiantes.\nDe Muchos a Uno: Muchas entidades están relacionadas con una sola.\nEjemplo: Muchos empleados trabajan en una empresa.\n\n\n14.0.1 Relación de Uno a Uno\n\n14.0.1.1 Descripción\n\nUna relación de uno a uno significa que cada entidad de una clase está relacionada con exactamente una entidad de otra clase.\nEjemplo: Una Persona tiene un Pasaporte.\n\npublic class Pasaporte {\n    private String numero;\n    private String pais;\n\n    // Constructor\n    public Pasaporte(String numero, String pais) {\n        this.numero = numero;\n        this.pais = pais;\n    }\n\n    // Métodos para obtener los valores\n    public String getNumero() {\n        return numero;\n    }\n\n    public String getPais() {\n        return pais;\n    }\n\n    @Override\n    public String toString() {\n        return \"Pasaporte [Número: \" + numero + \", País: \" + pais + \"]\";\n    }\n}\npublic class Persona {\n    private String nombre;\n    private Pasaporte pasaporte; // Relación de uno a uno con Pasaporte\n\n    // Constructor\n    public Persona(String nombre, Pasaporte pasaporte) {\n        this.nombre = nombre;\n        this.pasaporte = pasaporte;\n    }\n\n    // Métodos para obtener los valores\n    public String getNombre() {\n        return nombre;\n    }\n\n    public Pasaporte getPasaporte() {\n        return pasaporte;\n    }\n\n    @Override\n    public String toString() {\n        return \"Persona [Nombre: \" + nombre + \", \" + pasaporte.toString() + \"]\";\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        // Crear un pasaporte\n        Pasaporte pasaporte = new Pasaporte(\"123456\", \"Ecuador\");\n\n        // Crear una persona con un pasaporte\n        Persona persona = new Persona(\"Juan Pérez\", pasaporte);\n\n        // Mostrar los datos de la persona y su pasaporte\n        System.out.println(persona);\n    }\n}\n\ntoString\n\n14.0.2 ¿Qué es toString() y por qué se utiliza?\n14.0.2.1 ¿Qué es toString()?\nEl método toString() es un método que pertenece a la clase base de Java llamada Object, de la cual heredan todas las clases en Java. Este método está diseñado para devolver una representación en forma de cadena (texto) de un objeto.\nPor defecto, el método toString() devuelve:\n\nEl nombre completo de la clase.\nEl símbolo @.\nUn valor hash único del objeto.\n\nEjemplo del método por defecto:\n\n\npublic class Persona {\n    private String nombre;\n    private int edad;\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        Persona persona = new Persona(\"Juan\", 30);\n        System.out.println(persona.toString()); // Resultado por defecto\n    }\n}\n\n\n\nPersona:\n\nEs el nombre de la clase del objeto que estás imprimiendo.\nIndica que el objeto pertenece a la clase Persona.\n\n@:\n\nEs un separador que Java utiliza para distinguir el nombre de la clase del valor hash.\n\n15db9742:\n\nEs el “hashcode” del objeto.\nRepresenta un valor hexadecimal que es único para ese objeto en particular durante su ciclo de vida en memoria.\nEste hashcode se genera mediante el método hashCode() de la clase Object, y depende de la ubicación del objeto en la memoria.\n\npublic class Persona {\n    private String nombre;\n    private int edad;\n\n    public Persona(String nombre, int edad) {\n        this.nombre = nombre;\n        this.edad = edad;\n    }\n\n    @Override\n    public String toString() {\n        return \"Persona [Nombre: \" + nombre + \", Edad: \" + edad + \"]\";\n    }\n}\nLa diferencia principal entre sobrescribir el método toString() y crear un método personalizado como informacion() radica en el propósito y el uso estándar de cada uno.\n\nCuando intentas imprimir un objeto directamente (por ejemplo, con System.out.println(persona)), Java llama automáticamente a toString(). cuando utilizas un método personalizado debes llamarlo explícitamente, como persona.informacion(), para que funcione.\n\n @Override\n    public String toString() {\n        return \"Persona [Nombre: \" + nombre + \", Edad: \" + edad + \"]\";\n    }\n\n    public String informacion() {\n        return \"Persona [Nombre: \" + nombre + \", Edad: \" + edad + \"]\";\n    }\n}\nSystem.out.println(persona);\nSystem.out.println(persona.informacion());\n\n\nRelación de Uno a Muchos\n\n14.0.2.2 Descripción\n\nUna relación de uno a muchos significa que una entidad está conectada con varias otras.\nEjemplo: Un Maestro enseña a muchos Estudiantes.\n\n\n\npublic class Estudiante {\n    private String nombre;\n\n    // Constructor\n    public Estudiante(String nombre) {\n        this.nombre = nombre;\n    }\n\n    // Método para obtener el nombre\n    public String getNombre() {\n        return nombre;\n    }\n\n    @Override\n    public String toString() {\n        return \"Estudiante [Nombre: \" + nombre + \"]\";\n    }\n}\nimport java.util.List;\n\npublic class Maestro {\n    private String nombre;\n    private List&lt;Estudiante&gt; estudiantes; // Relación de uno a muchos con Estudiantes\n\n    // Constructor\n    public Maestro(String nombre, List&lt;Estudiante&gt; estudiantes) {\n        this.nombre = nombre;\n        this.estudiantes = estudiantes;\n    }\n\n    // Métodos para obtener los valores\n    public String getNombre() {\n        return nombre;\n    }\n\n    public List&lt;Estudiante&gt; getEstudiantes() {\n        return estudiantes;\n    }\n\n    @Override\n    public String toString() {\n        return \"Maestro [Nombre: \" + nombre + \", Estudiantes: \" + estudiantes + \"]\";\n    }\n}\nimport java.util.Arrays;\n\npublic class Main {\n    public static void main(String[] args) {\n        // Crear estudiantes\n        Estudiante estudiante1 = new Estudiante(\"Ana López\");\n        Estudiante estudiante2 = new Estudiante(\"Carlos Martínez\");\n        Estudiante estudiante3 = new Estudiante(\"Lucía Gómez\");\n\n        // Crear un maestro con una lista de estudiantes\n        Maestro maestro = new Maestro(\"Profesor Pérez\", Arrays.asList(estudiante1, estudiante2, estudiante3));\n\n        // Mostrar los datos del maestro y sus estudiantes\n        System.out.println(maestro);\n    }\n}\n\n\n\n14.0.3 Relación de Muchos a Uno\n\n14.0.3.1 Descripción\n\nUna relación de muchos a uno significa que muchas entidades están relacionadas con una sola.\nEjemplo: Muchos Empleados trabajan en una Empresa.\n\npublic class Empresa {\n    private String nombre;\n\n    // Constructor\n    public Empresa(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    @Override\n    public String toString() {\n        return \"Empresa [Nombre: \" + nombre + \"]\";\n    }\n}\npublic class Empleado {\n    private String nombre;\n    private Empresa empresa; // Relación de muchos a uno con Empresa\n\n    // Constructor\n    public Empleado(String nombre, Empresa empresa) {\n        this.nombre = nombre;\n        this.empresa = empresa;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public Empresa getEmpresa() {\n        return empresa;\n    }\n\n    @Override\n    public String toString() {\n        return \"Empleado [Nombre: \" + nombre + \", \" + empresa.toString() + \"]\";\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        // Crear una empresa\n        Empresa empresa = new Empresa(\"TechCorp\");\n\n        // Crear empleados asociados a la empresa\n        Empleado empleado1 = new Empleado(\"Pedro Gómez\", empresa);\n        Empleado empleado2 = new Empleado(\"María López\", empresa);\n\n        // Mostrar los datos de los empleados y su empresa\n        System.out.println(empleado1);\n        System.out.println(empleado2);\n    }\n}\n\n\n\n14.0.4 Relaciones entre Clases en Java: Asociación, Agregación y Composición\nEn Java, las relaciones entre clases se clasifican según cómo están conectadas las clases. Las más comunes son:\n\nAsociación:\nUna clase está relacionada con otra, pero ambas pueden existir de forma independiente.\nEjemplo: Un maestro enseña a estudiantes.\nAgregación:\nUna clase contiene otra, pero ambas pueden existir por separado.\nEjemplo: Una escuela tiene maestros, pero si la escuela cierra, los maestros pueden trabajar en otro lugar.\nComposición:\nUna clase contiene otra y no pueden existir separadas.\nEjemplo: Una casa tiene una dirección, y sin dirección, la casa no tiene sentido."
  },
  {
    "objectID": "Unidades/ejercicio1/ejercicio.html",
    "href": "Unidades/ejercicio1/ejercicio.html",
    "title": "15  Ejercicio Complementario",
    "section": "",
    "text": "15.0.1 Enunciado: Sistema de Gestión de Biblioteca\nInstrucciones: Diseña y desarrolla un programa en Java que represente un Sistema de Gestión de Biblioteca. El programa debe permitir:\n-registrar libros\n-usuarios\n-gestionar préstamos.\nAplica los conceptos básicos de Programación Orientada a Objetos (POO) que has aprendido en clase. A continuación, se detallan los requerimientos:\n\nModelado de Clases y Objetos:\n\nCrea tres clases principales: Libro, Usuario y Biblioteca.\nRelaciona las clases para que la biblioteca administre los libros y usuarios, y cada usuario pueda tener varios libros prestados.\n\nEstructura del Programa:\n\nEl programa debe comenzar mostrando un menú con las opciones:\n\nRegistrar un libro.\nRegistrar un usuario.\nPrestar un libro.\nDevolver un libro.\nMostrar el listado de libros disponibles y prestados.\n\n\nEncapsulamiento:\n\nLos atributos de las clases deben ser privados y accesibles únicamente a través de métodos getters y setters.\n\nConstructores:\n\nImplementa constructores para inicializar los objetos con datos (PARAMETRIZADO) como título del libro, autor, nombre del usuario, etc.\n\nGestión de Errores (Excepciones):\n\nSi un usuario intenta prestar un libro que no existe o que ya está prestado, el programa debe mostrar un mensaje de error y continuar funcionando.\n\nPersistencia de Datos:\n\nLos libros y usuarios registrados deben guardarse en un archivo de texto, y el programa debe cargar estos datos al iniciar.\n\nColecciones y Arreglos:\n\nUsa una lista (ArrayList) para gestionar los libros y usuarios registrados.\n\n\nPASOS A REALIZAR.\n\n\n15.0.2 RESUMEN\nVamos a realizar un programa para gestionar una biblioteca, donde debe contener un menú ( lo puedo colocar en el main, o crear una clase y llamarla cuando la necesite), el programa deberá permitir crear usuarios, registrar libros, gestionar préstamos de los libros a los usuarios.\nLos datos deberán cargarse al sistema cuando se inice, en caso que algún libro no exista o está prestado deberá presentar una alerta.\nLas clases deben ser privadas, pero con un constructor parametrizado para la creación, no para la modificación.\nExisten varios libros (necesito un array del objeto Libro que lo maneja BIBLIOTECA).\nExisten varios usuarios ( necesito un array del objeto usuario que lo maneja BIBLIOTECA).\nAtributos usuario y Métodos usuario\nID , Nombre, LibroPrestado (para saber cual libro se ha prestado al usuario).\ngetLibrosPrestados(), agregarLibro, devolverLibro\nAdemás el usuario no debe poder modificar información por lo que necesita getter de ID, Nombre. pero no debe modificar\nAtributos Libro (yo debo colocar).\nID, Titulo, Autor, Prestado (V o F).\nLos métodos de libro que puede observar (get) ID, titulo, Autor, Prestado.\nLos que puede modificar (set) setPrestado.\nLa clase que administra es Biblioteca.\nAtributos: Arrays de libro y usuario.\nMétodos: registrarLibro() , registrarUsuario() , prestarLibro() , devolverLibro(), mostrarLibrosDisponibles()\n\n\n15.0.3 DIAGRAMA UML\n\n\n\n\n\n\n\n15.0.4 CODIFICACIÓN\n\n15.0.4.1 Clase Libro\n\n\npublic class Libro {\n    private static int contadorId = 1; // Atributo estático\n    private final int id; // ID único, final para no permitir cambios\n    private String titulo;\n    private String autor;\n    private boolean prestado;\n\n    public Libro(String titulo, String autor) {\n        this.id = contadorId++;\n        this.titulo = titulo;\n        this.autor = autor;\n        this.prestado = false;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getTitulo() {\n        return titulo;\n    }\n\n    public void setTitulo(String titulo) {\n        this.titulo = titulo;\n    }\n\n    public String getAutor() {\n        return autor;\n    }\n\n    public void setAutor(String autor) {\n        this.autor = autor;\n    }\n\n    public boolean isPrestado() {\n        return prestado;\n    }\n\n    public void setPrestado(boolean prestado) {\n        this.prestado = prestado;\n    }\n\n    @Override\n    public String toString() {\n        return \"ID: \" + id + \", Título: \" + titulo + \", Autor: \" + autor + \", Prestado: \" + (prestado ? \"Sí\" : \"No\");\n    }\n}\n\n\n\n\n\n\n\n\n\n\n15.0.4.2 Clase Usuario\n\n\n\n\n\n\n\n\nimport java.util.ArrayList;\n\npublic class Usuario {\n    private static int contadorId = 1; // Atributo estático\n    private final int id; // ID único, final para no permitir cambios\n    private String nombre;\n    private ArrayList&lt;Libro&gt; librosPrestados;\n\n    public Usuario(String nombre) {\n        this.id = contadorId++;\n        this.nombre = nombre;\n        this.librosPrestados = new ArrayList&lt;&gt;();\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getNombre() {\n        return nombre;\n    }\n\n    public void setNombre(String nombre) {\n        this.nombre = nombre;\n    }\n\n    public void agregarLibroPrestado(Libro libro) {\n        librosPrestados.add(libro);\n    }\n\n    public void devolverLibro(Libro libro) {\n        librosPrestados.remove(libro);\n    }\n\n    public ArrayList&lt;Libro&gt; getLibrosPrestados() {\n        return librosPrestados;\n    }\n\n    @Override\n    public String toString() {\n        return \"ID: \" + id + \", Nombre: \" + nombre;\n    }\n}\n\n\n\n\n15.0.4.3 Clase Biblioteca\n\n\n\nimport java.util.ArrayList;\n\npublic class Biblioteca {\n    private ArrayList&lt;Libro&gt; libros;\n    private ArrayList&lt;Usuario&gt; usuarios;\n\n    // Constructor\n    public Biblioteca() {\n        this.libros = new ArrayList&lt;&gt;();\n        this.usuarios = new ArrayList&lt;&gt;();\n    }\n\n    // Método para agregar un nuevo libro\n    public void agregarLibro(String titulo, String autor) {\n        Libro libro = new Libro(titulo, autor);\n        libros.add(libro);\n        System.out.println(\"Libro agregado: \" + libro.getTitulo() + \" con ID: \" + libro.getId());\n    }\n\n    // Método para registrar un usuario\n    public void registrarUsuario(String nombre) {\n        Usuario usuario = new Usuario(nombre);\n        usuarios.add(usuario);\n        System.out.println(\"Usuario registrado: \" + usuario.getNombre() + \" con ID: \" + usuario.getId());\n    }\n\n    // Método para prestar un libro\n    public void prestarLibro(int idUsuario, int idLibro) {\n        Usuario usuario = buscarUsuario(idUsuario);\n        Libro libro = buscarLibro(idLibro);\n        \n        if (usuario != null && libro != null) {\n            if (!libro.isPrestado()) {\n                libro.setPrestado(true);\n                usuario.agregarLibroPrestado(libro);\n                System.out.println(\"El libro '\" + libro.getTitulo() + \"' ha sido prestado a \" + usuario.getNombre());\n            } else {\n                System.out.println(\"El libro ya está prestado.\");\n            }\n        } else {\n            System.out.println(\"Usuario o libro no encontrado.\");\n        }\n    }\n\n    // Método para devolver un libro\n    public void devolverLibro(int idUsuario, int idLibro) {\n        Usuario usuario = buscarUsuario(idUsuario);\n        Libro libro = buscarLibro(idLibro);\n        \n        if (usuario != null && libro != null) {\n            if (libro.isPrestado()) {\n                libro.setPrestado(false);\n                usuario.devolverLibro(libro);\n                System.out.println(\"El libro '\" + libro.getTitulo() + \"' ha sido devuelto por \" + usuario.getNombre());\n            } else {\n                System.out.println(\"El libro no estaba prestado.\");\n            }\n        } else {\n            System.out.println(\"Usuario o libro no encontrado.\");\n        }\n    }\n\n    // Método para mostrar los libros disponibles\n    public void mostrarLibrosDisponibles() {\n        System.out.println(\"\\n--- Lista de libros disponibles ---\");\n        boolean hayLibros = false;\n        for (Libro libro : libros) {\n            if (!libro.isPrestado()) {\n                System.out.println(\"ID: \" + libro.getId() + \" - Título: \" + libro.getTitulo() + \" - Autor: \" + libro.getAutor());\n                hayLibros = true;\n            }\n        }\n        if (!hayLibros) {\n            System.out.println(\" No hay libros disponibles.\");\n        }\n    }\n    \n    // Método para mostrar usuarios disponibles\n    public void mostrarUsuariosDisponibles() {\n        System.out.println(\"\\n--- Lista de usuarios disponibles ---\");\n        if (usuarios.isEmpty()) {\n            System.out.println(\" No hay usuarios registrados.\");\n        } else {\n            for (Usuario usuario : usuarios) {\n                System.out.println(\"ID: \" + usuario.getId() + \" - Nombre: \" + usuario.getNombre());\n            }\n        }\n    }\n    \n    // Método para mostrar los usuarios con libros prestados\n    public void mostrarUsuariosConLibrosPrestados() {\n        System.out.println(\"\\n--- Lista de usuarios con libros prestados ---\");\n        boolean hayUsuariosConLibros = false;\n        \n        for (Usuario usuario : usuarios) {\n            if (!usuario.getLibrosPrestados().isEmpty()) {\n                System.out.println(\" ID: \" + usuario.getId() + \" - Nombre: \" + usuario.getNombre() + \n                                   \" - Libros prestados: \" + usuario.getLibrosPrestados().size());\n                hayUsuariosConLibros = true;\n            }\n        }\n        \n        if (!hayUsuariosConLibros) {\n            System.out.println(\"No hay usuarios con libros prestados.\");\n        }\n    }\n\n    // Método para mostrar los libros prestados a un usuario específico\n    public void mostrarLibrosPrestados(int idUsuario) {\n        Usuario usuario = buscarUsuario(idUsuario);\n        \n        if (usuario != null) {\n            System.out.println(\"\\n--- Libros prestados al usuario \" + usuario.getNombre() + \" ---\");\n            if (!usuario.getLibrosPrestados().isEmpty()) {\n                for (Libro libro : usuario.getLibrosPrestados()) {\n                    System.out.println(\"ID: \" + libro.getId() + \" - Título: \" + libro.getTitulo() + \" - Autor: \" + libro.getAutor());\n                }\n            } else {\n                System.out.println(\" El usuario no tiene libros prestados.\");\n            }\n        } else {\n            System.out.println(\"Usuario no encontrado.\");\n        }\n    }\n\n    // Método para buscar un libro\n    private Libro buscarLibro(int idLibro) {\n        for (Libro libro : libros) {\n            if (libro.getId() == idLibro) {\n                return libro;\n            }\n        }\n        return null;\n    }\n\n    // Método para buscar un usuario\n    private Usuario buscarUsuario(int idUsuario) {\n        for (Usuario usuario : usuarios) {\n            if (usuario.getId() == idUsuario) {\n                return usuario;\n            }\n        }\n        return null;\n    }\n}\n\n\n\n\n\n\n\n\n\n\n15.0.4.4 Clase Main\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Biblioteca biblioteca = new Biblioteca();\n        Scanner scanner = new Scanner(System.in);\n        int opcion = 0;\n\n        do {\n            System.out.println(\"\\n--- Menú de la Biblioteca ---\");\n            System.out.println(\"1. Agregar libro\");\n            System.out.println(\"2. Registrar usuario\");\n            System.out.println(\"3. Prestar libro\");\n            System.out.println(\"4. Devolver libro\");\n            System.out.println(\"5. Mostrar libros disponibles\");\n            System.out.println(\"6. Mostrar usuarios con libros prestados\");\n            System.out.println(\"7. Salir\");\n            System.out.print(\"Ingrese una opción: \");\n\n            try {\n                opcion = scanner.nextInt();\n                scanner.nextLine(); // Limpiar el buffer de entrada\n            } catch (InputMismatchException e) {\n                System.out.println(\"Opción no válida, debe ser un número.\");\n                scanner.nextLine(); // Limpiar el buffer de entrada\n                continue;\n            }\n\n            switch (opcion) {\n                case 1:\n                    System.out.print(\"Ingrese el título del libro: \");\n                    String titulo = scanner.nextLine();\n                    System.out.print(\"Ingrese el autor del libro: \");\n                    String autor = scanner.nextLine();\n                    biblioteca.agregarLibro(titulo, autor);\n                    break;\n\n                case 2:\n                    System.out.print(\"Ingrese el nombre del usuario: \");\n                    String nombre = scanner.nextLine();\n                    biblioteca.registrarUsuario(nombre);\n                    System.out.println(\" Usuario registrado exitosamente.\");\n                    break;\n\n                case 3:\n                    System.out.println(\"\\n--- Lista de usuarios ---\");\n                    biblioteca.mostrarUsuariosDisponibles();\n                    \n                    try {\n                        System.out.print(\"\\nIngrese el ID del usuario que tomará el libro: \");\n                        int idUsuarioPrestar = scanner.nextInt();\n                        scanner.nextLine(); // Limpiar el buffer de entrada\n                        \n                        System.out.println(\"\\n--- Lista de libros disponibles ---\");\n                        biblioteca.mostrarLibrosDisponibles();\n                        \n                        System.out.print(\"\\nIngrese el ID del libro a prestar: \");\n                        int idLibroPrestar = scanner.nextInt();\n                        scanner.nextLine(); // Limpiar el buffer de entrada\n                        \n                        biblioteca.prestarLibro(idUsuarioPrestar, idLibroPrestar);\n                        System.out.println(\"Libro prestado exitosamente.\");\n                    } catch (InputMismatchException e) {\n                        System.out.println(\"Error: El ID debe ser un número.\");\n                        scanner.nextLine(); // Limpiar el buffer de entrada\n                    }\n                    break;\n\n                case 4:\n                    System.out.println(\"\\n--- Lista de usuarios con libros prestados ---\");\n                    biblioteca.mostrarUsuariosConLibrosPrestados();\n                    \n                    try {\n                        System.out.print(\"\\nIngrese el ID del usuario que devolverá el libro: \");\n                        int idUsuarioDevolver = scanner.nextInt();\n                        scanner.nextLine(); // Limpiar el buffer de entrada\n                        \n                        System.out.println(\"\\n--- Lista de libros prestados ---\");\n                        biblioteca.mostrarLibrosPrestados(idUsuarioDevolver);\n                        \n                        System.out.print(\"\\nIngrese el ID del libro a devolver: \");\n                        int idLibroDevolver = scanner.nextInt();\n                        scanner.nextLine(); // Limpiar el buffer de entrada\n                        \n                        biblioteca.devolverLibro(idUsuarioDevolver, idLibroDevolver);\n                        System.out.println(\"Libro devuelto exitosamente.\");\n                    } catch (InputMismatchException e) {\n                        System.out.println(\"Error: El ID debe ser un número.\");\n                        scanner.nextLine(); // Limpiar el buffer de entrada\n                    }\n                    break;\n\n                case 5:\n                    System.out.println(\"\\n--- Lista de libros disponibles ---\");\n                    biblioteca.mostrarLibrosDisponibles();\n                    break;\n                        \n                case 6:\n                    biblioteca.mostrarUsuariosConLibrosPrestados();\n                    break;\n                    \n                case 7:\n                    System.out.println(\"Saliendo...\");\n                    break;\n                    \n                default:\n                    System.out.println(\"Opción no válida.\");\n            }\n        } while (opcion != 7);\n        \n        scanner.close();\n    }\n}\n\n\n\n15.0.5 Conceptos Aplicados\n\nModelamiento de Clases y Objetos: Se modelaron las clases Libro, Usuario y Biblioteca.\nEncapsulamiento: Los atributos están privados y solo se acceden mediante getters y setters.\nConstructores: Los objetos Libro y Usuario se crean con un constructor.\nGetters y Setters: Se accede y modifica la información de los objetos a través de getters y setters.\nRelaciones entre Clases:\n\nBiblioteca tiene una relación de agregación con Usuario y Libro.\nUsuario tiene una relación de composición con la lista de libros prestados.\n\nExcepciones: Aunque no se manejan excepciones explícitas, se pueden añadir para controlar la entrada de datos.\nPersistencia de Datos: Se podría extender la persistencia a un archivo, pero actualmente se gestiona en memoria.\nArreglos y Colecciones: Se utilizan ArrayList para la lista de usuarios y la lista de libros.\nEstructura General de un Programa: La clase Main orquesta la lógica principal de la aplicación.\nLectura y Escritura por Consola: Los mensajes se muestran en la consola para facilitar la interacción con el usuario."
  },
  {
    "objectID": "summary.html",
    "href": "summary.html",
    "title": "16  Summary",
    "section": "",
    "text": "In summary, this book has no content whatsoever."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97."
  }
]